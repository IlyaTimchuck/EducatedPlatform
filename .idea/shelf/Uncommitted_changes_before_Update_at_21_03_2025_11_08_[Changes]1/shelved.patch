Index: handlers/command_menu_admin.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from aiogram.types import Message\r\nfrom aiogram.fsm.context import FSMContext\r\nfrom aiogram import Router\r\n\r\n\r\nimport state as st\r\nimport database as db\r\nimport keyboard as kb\r\n\r\n\r\nrouter = Router()\r\n\r\n\r\n@router.message(st.AddUsers.choose_course)\r\nasync def process_choose_course(message: Message, state: FSMContext):\r\n    if message.text == 'Создать новый':\r\n        await message.answer('Отправь мне название курса')\r\n        await state.set_state(st.AddUsers.get_course_tittle)\r\n    else:\r\n        await state.update_data(course_tittle=message.text)\r\n        await message.answer('Отправь мне список пользователей')\r\n        await state.set_state(st.AddUsers.get_list_users)\r\n\r\n\r\n@router.message(st.AddUsers.get_course_tittle)\r\nasync def process_get_course_tittle(message: Message, state: FSMContext):\r\n    await state.update_data(course_tittle=message.text)\r\n    await db.create_course(message.text)\r\n    await message.answer('Отправь мне список пользователей')\r\n    await state.set_state(st.AddUsers.get_list_users)\r\n\r\n\r\n@router.message(st.AddUsers.get_list_users)\r\nasync def process_get_list_users(message: Message, state: FSMContext):\r\n    list_users = message.text.split('\\n')\r\n    data = await state.get_data()\r\n    course_id = await db.get_course_id(data['course_tittle'])\r\n    await db.add_users(list_users, course_id)\r\n    _, keyboard = kb.send_command_menu(message.from_user.id)\r\n    await message.answer('Пользователи были успешно добавлены', reply_markup=keyboard)\r\n\r\n\r\n@router.message(st.AddTask.get_task_title)\r\nasync def process_get_task_title(message: Message, state: FSMContext):\r\n    await state.update_data(task_title=message.text)\r\n    await message.answer('Название было успешно записано. Теперь отправь мне видеозапись урока')\r\n    await state.set_state(st.AddTask.get_video)\r\n\r\n\r\n@router.message(st.AddTask.get_video)\r\nasync def process_get_video(message: Message, state: FSMContext):\r\n    await state.update_data(video_id=message.video.file_id)\r\n    await message.answer('Видео было успешно записано. Теперь отправь конспект урока')\r\n    await state.set_state(st.AddTask.get_abstract)\r\n\r\n\r\n@router.message(st.AddTask.get_abstract)\r\nasync def process_get_abstract(message: Message, state: FSMContext):\r\n    await state.update_data(abstract_id=message.document.file_id)\r\n    await message.answer('Добавь условия и ответы в гугл таблицу', reply_markup=kb.send_exercise )\r\n    await state.set_state(st.AddTask.verification)\r\n\r\n\r\n# @router.message(st.AddTask.get_homework)\r\n# async def process_get_homework(message: Message, state: FSMContext):\r\n#     state_data = await state.get_data()\r\n#     task_id = await db.get_task_id()\r\n#     if state_data['manual_verification']:\r\n#         condition = message.text\r\n#         await db.add_exercise(state_data[])\r\n#\r\n#     data = message.text.split('ОТВЕТ')\r\n#     condition = data[0]\r\n#     answer = data[-1].lstrip()\r\n#     await db.add_exercise(state_data['task_id'], state_data['exercise_number'], condition, answer)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/handlers/command_menu_admin.py b/handlers/command_menu_admin.py
--- a/handlers/command_menu_admin.py	(revision b0591667e66263e7d38695590eb03be98f9ba183)
+++ b/handlers/command_menu_admin.py	(date 1742544483784)
@@ -36,7 +36,7 @@
     data = await state.get_data()
     course_id = await db.get_course_id(data['course_tittle'])
     await db.add_users(list_users, course_id)
-    _, keyboard = kb.send_command_menu(message.from_user.id)
+    _, keyboard = await kb.send_command_menu(message.from_user.id)
     await message.answer('Пользователи были успешно добавлены', reply_markup=keyboard)
 
 
@@ -60,16 +60,3 @@
     await message.answer('Добавь условия и ответы в гугл таблицу', reply_markup=kb.send_exercise )
     await state.set_state(st.AddTask.verification)
 
-
-# @router.message(st.AddTask.get_homework)
-# async def process_get_homework(message: Message, state: FSMContext):
-#     state_data = await state.get_data()
-#     task_id = await db.get_task_id()
-#     if state_data['manual_verification']:
-#         condition = message.text
-#         await db.add_exercise(state_data[])
-#
-#     data = message.text.split('ОТВЕТ')
-#     condition = data[0]
-#     answer = data[-1].lstrip()
-#     await db.add_exercise(state_data['task_id'], state_data['exercise_number'], condition, answer)
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from asyncio import run, create_task, CancelledError\r\nfrom aiogram import Bot, Dispatcher\r\nfrom handlers.__init__ import setup_routers\r\nfrom callbacks.__init__ import setup_routers_callbacks\r\nfrom deadline import setup_monitoring\r\nimport database as db\r\n\r\n\r\n\r\nasync def main() -> None:\r\n    bot = Bot('7667517965:AAGehj0I0nCwYFLBYTlpG2a4D5YQElh7qK0')\r\n    dp = Dispatcher()\r\n    setup_routers(dp)\r\n    setup_routers_callbacks(dp)\r\n    await db.create_db()\r\n    await db.create_course('Тестовый')\r\n    course_id = await db.get_course_id('Тестовый')\r\n    await db.add_users(['f'], course_id)\r\n    await db.add_users(['try_user'], course_id)\r\n    await db.create_block(course_id, 2)\r\n    monitor_task = create_task(setup_monitoring(bot))\r\n    task_id = await db.add_task('Задание 16', course_id, 'Автоматическая проверка',\r\n                                'BAACAgIAAxkBAAIFk2ecdMIb9MARHD1FCDBfDykIyVA8AAIQYAAChk_gSJ5yxpryw_xrNgQ',\r\n                                'BQACAgIAAxkBAAID4GeW8STy6kbcasFhPk_ZNds1Q5u1AAKwdAACV7G4SHyUzFl8D_k0NgQ',\r\n                                True, '2025-03-14')\r\n    await db.add_exercise(task_id,\r\n                          'Узлы с IP-адресами 157.220.185.237 и 157.220.184.230 принадлежат одной сети. Какое наименьшее количество IP-адресов, в двоичной записи которых ровно 15 единиц, может содержаться в этой сети?',\r\n                          '12')\r\n    await db.add_exercise(task_id,\r\n                          'Сеть, в которой содержится узел с IP-адресом 192.214.A.184, задана маской сети 255.255.255.224, где A - некоторое допустимое для записи IP-адреса число. Определите минимальное значение A, для которого для всех IP-адресов этой сети в двоичной записи IP-адреса суммарное количество единиц будет больше 15.',\r\n                          '43')\r\n    await db.add_exercise(task_id ,\r\n                          '''В снежном королевстве существовала особая сеть, которая имела свой уникальный IP-адрес и маску.\r\nОднажды, Снежная Королева решила провести эксперимент, чтобы выяснить, сколько IP-адресов в её королевстве соответствуют определённому правилу. Она знала, что сеть ее королевства задается следующими данными:\r\nIP-адрес сети: 192.168.248.176\r\nСетевая маска: 255.255.255.240\r\nНеобходимо узнать, сколько в этой сети IP-адресов, для которых количество единиц и нулей в двоичной записи IP-адреса одинаково.''',\r\n                          '43')\r\n\r\n    # task_id1 = await db.add_task('Тестовый 2', course_id, 'Автоматическая проверка',\r\n    #                             'BAACAgIAAxkBAAIFk2ecdMIb9MARHD1FCDBfDykIyVA8AAIQYAAChk_gSJ5yxpryw_xrNgQ',\r\n    #                             'BQACAgIAAxkBAAID4GeW8STy6kbcasFhPk_ZNds1Q5u1AAKwdAACV7G4SHyUzFl8D_k0NgQ',\r\n    #                             True, '2025-03-10')\r\n    # await db.add_exercise(task_id1,\r\n    #                       '''Хуй попа жопа''',\r\n    #                       'сиси')\r\n    try:\r\n        await dp.start_polling(bot)\r\n    finally:\r\n        monitor_task.cancel()\r\n        try:\r\n            await monitor_task\r\n        except CancelledError:\r\n            print(\"Monitoring task cancelled\")\r\n        await bot.session.close()\r\n\r\n\r\nif __name__ == '__main__':\r\n    run(main())\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision b0591667e66263e7d38695590eb03be98f9ba183)
+++ b/main.py	(date 1742544483810)
@@ -2,13 +2,13 @@
 from aiogram import Bot, Dispatcher
 from handlers.__init__ import setup_routers
 from callbacks.__init__ import setup_routers_callbacks
+from bot_instance import bot
 from deadline import setup_monitoring
 import database as db
 
 
 
 async def main() -> None:
-    bot = Bot('7667517965:AAGehj0I0nCwYFLBYTlpG2a4D5YQElh7qK0')
     dp = Dispatcher()
     setup_routers(dp)
     setup_routers_callbacks(dp)
@@ -17,12 +17,11 @@
     course_id = await db.get_course_id('Тестовый')
     await db.add_users(['f'], course_id)
     await db.add_users(['try_user'], course_id)
-    await db.create_block(course_id, 2)
     monitor_task = create_task(setup_monitoring(bot))
     task_id = await db.add_task('Задание 16', course_id, 'Автоматическая проверка',
                                 'BAACAgIAAxkBAAIFk2ecdMIb9MARHD1FCDBfDykIyVA8AAIQYAAChk_gSJ5yxpryw_xrNgQ',
                                 'BQACAgIAAxkBAAID4GeW8STy6kbcasFhPk_ZNds1Q5u1AAKwdAACV7G4SHyUzFl8D_k0NgQ',
-                                True, '2025-03-14')
+                                True, '2025-03-21')
     await db.add_exercise(task_id,
                           'Узлы с IP-адресами 157.220.185.237 и 157.220.184.230 принадлежат одной сети. Какое наименьшее количество IP-адресов, в двоичной записи которых ровно 15 единиц, может содержаться в этой сети?',
                           '12')
Index: handlers/command_menu_student.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from aiogram.types import Message\r\nfrom aiogram.fsm.context import FSMContext\r\nfrom aiogram.types import CallbackQuery\r\nfrom aiogram import Router, F\r\n\r\n\r\nimport state as st\r\nimport database as db\r\nimport keyboard as kb\r\n\r\n\r\nrouter = Router()\r\n\r\n@router.callback_query(F.data == 'list_lives')\r\nasync def opening_list_lives(callback_query: CallbackQuery):\r\n    await callback_query.answer()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/handlers/command_menu_student.py b/handlers/command_menu_student.py
--- a/handlers/command_menu_student.py	(revision b0591667e66263e7d38695590eb03be98f9ba183)
+++ b/handlers/command_menu_student.py	(date 1742544483807)
@@ -3,14 +3,27 @@
 from aiogram.types import CallbackQuery
 from aiogram import Router, F
 
-
 import state as st
 import database as db
 import keyboard as kb
 
-
 router = Router()
 
+
 @router.callback_query(F.data == 'list_lives')
 async def opening_list_lives(callback_query: CallbackQuery):
     await callback_query.answer()
+    history_lives_user = await db.get_history_lives_user(callback_query.from_user.id)
+    text_message = "📝 История изменений жизней:\n\n"
+    for change in history_lives_user:
+        action = change['action']
+        if action == '-1':
+            if change['task_title']:
+                text_message += f'{action}❤️ Просрочен дедлайн к уроку {change['task_title']}\n'
+            else:
+                text_message += f'{action}❤️ Индивидуальное обновление жизней\n'
+        elif action == '+3':
+            text_message += f'{action}❤️ Новый блок!\n'
+        else:
+            text_message += f'{action}❤️ Индивидуальное обновление жизней\n'
+    await callback_query.message.edit_text(text=text_message, reply_markup=kb.back_button_admin)
Index: database.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from typing import Any, Coroutine\r\nfrom zoneinfo import ZoneInfo\r\nfrom datetime import datetime, timedelta\r\nimport aiosqlite\r\nfrom collections import defaultdict\r\n\r\n\r\ndef current_datetime():\r\n    return datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\r\n\r\n\r\nasync def create_db() -> None:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        await con.execute(\"DROP TABLE IF EXISTS unregistered\")\r\n        await con.execute(\"DROP TABLE IF EXISTS users\")\r\n        await con.execute(\"DROP TABLE IF EXISTS courses\")\r\n        await con.execute(\"DROP TABLE IF EXISTS blocks\")\r\n        await con.execute(\"DROP TABLE IF EXISTS tasks\")\r\n        await con.execute(\"DROP TABLE IF EXISTS exercises\")\r\n        await con.execute(\"DROP TABLE IF EXISTS learning_progress\")\r\n        await con.execute(\"DROP TABLE IF EXISTS sessions\")\r\n        await con.execute(\"DROP TABLE IF EXISTS changed_deadlines\")\r\n        await con.execute(\"DROP TABLE IF EXISTS unique_timezones\")\r\n        await con.execute(\"DROP TABLE IF EXISTS history_of_lives\")\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS unregistered (\r\n            username TEXT,\r\n            course_id INTEGER)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS users (\r\n            username TEXT,\r\n            user_id INTEGER,\r\n            course_id INTEGER,\r\n            timezone_id TEXT,\r\n            date_of_joining TEXT,\r\n            lives INTEGER,\r\n            role TEXT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS courses(\r\n            course_title TEXT,\r\n            course_id INTEGER PRIMARY KEY AUTOINCREMENT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS blocks (\r\n            course_id INTEGER,\r\n            block_number INTEGER, \r\n            block_start TEXT,\r\n            block_id INTEGER PRIMARY KEY AUTOINCREMENT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS tasks (\r\n            task_title TEXT,\r\n            task_id INTEGER PRIMARY KEY AUTOINCREMENT, \r\n            block_id INTEGER,\r\n            verification TEXT,\r\n            video_id TEXT,\r\n            abstract_id TEXT,\r\n            availability_files BOOL,\r\n            deadline TEXT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS exercises (\r\n             task_id INTEGER,\r\n             exercise_id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n             exercise_condition TEXT,\r\n             exercise_answer TEXT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS learning_progress (\r\n             user_id INTEGER, \r\n             exercise_id INTEGER, \r\n             input_answer TEXT, \r\n             right_answer BOOL, \r\n             session_id INTEGER)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS sessions (\r\n            session_id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n            user_id INTEGER,\r\n            task_id INTEGER,\r\n            is_completed BOOL,\r\n            session_start TEXT,\r\n            session_end TEXT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS changed_deadlines (\r\n                user_id INTEGER,\r\n                task_id INTEGER,\r\n                deadline TEXT,\r\n                PRIMARY KEY (user_id, task_id))''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS unique_timezones (\r\n            timezone TEXT,\r\n            timezone_id INTEGER PRIMARY KEY AUTOINCREMENT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS history_of_lives (\r\n            user_id INTEGER,\r\n            task_id INTEGER,\r\n            current_lives INTEGER)''')\r\n\r\n        await con.commit()\r\n\r\n\r\n# Registration\r\nasync def create_course(course_title) -> None:\r\n    block_start = datetime.now().strftime(\"%Y-%m-%d\")\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        await con.execute('INSERT INTO courses (course_title) VALUES(?)', (course_title,))\r\n        await con.commit()\r\n        course_id = await get_course_id(course_title)\r\n        await con.execute('INSERT INTO blocks (course_id, block_start, block_number) VALUES(?, ?, ?)',\r\n                          (course_id, block_start, 1))\r\n        await con.commit()\r\n\r\n\r\nasync def add_users(usernames: list, course_id: int) -> None:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        for user in usernames:\r\n            await con.execute('INSERT INTO unregistered VALUES(?, ?)', (user, course_id))\r\n        await con.commit()\r\n\r\n\r\nasync def user_is_unregistered(username: str) -> bool:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        result = await con.execute('''SELECT EXISTS \r\n        (SELECT 1 FROM unregistered WHERE username = ?)''', (username,))\r\n        row = await result.fetchone()\r\n        return bool(row[0])\r\n\r\n\r\nasync def registration_user(username: str, user_id: int, timezone: str, role: str) -> None:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        tz_record = await (await con.execute(\r\n            \"SELECT timezone_id FROM unique_timezones WHERE timezone = ?\",\r\n            (timezone,))).fetchone()\r\n\r\n        if not tz_record:\r\n            await con.execute(\r\n                \"INSERT INTO unique_timezones (timezone) VALUES (?)\",\r\n                (timezone,)\r\n            )\r\n            tz_record = await (await con.execute(\"SELECT last_insert_rowid()\")).fetchone()\r\n\r\n        timezone_id = tz_record[0]\r\n        date_of_joining = current_datetime()\r\n        lives = 3\r\n        cursor = await con.execute('SELECT course_id FROM unregistered WHERE username = ?', (username,))\r\n        course_id = await cursor.fetchone()\r\n        if course_id:\r\n            await con.execute('INSERT INTO users VALUES (?, ?, ?, ?, ?, ?, ?)',\r\n                              (username, user_id, course_id[0], timezone_id, date_of_joining, lives, role))\r\n            await con.execute('DELETE FROM unregistered WHERE username = ?', (username,))\r\n            await con.commit()\r\n        return course_id\r\n\r\n\r\n# Other function\r\nasync def get_data_user(user_id: int) -> dict:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        async with con.cursor() as cursor:\r\n            await cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))\r\n            row = await cursor.fetchone()\r\n            if row:\r\n                return dict(row)\r\n            else:\r\n                return {}\r\n\r\n\r\nasync def get_list_courses() -> list:\r\n    \"\"\"Возвращает список всех названий курсов из базы данных.\"\"\"\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = 'SELECT course_title, course_id FROM courses'\r\n        async with con.execute(query) as cursor:\r\n            rows = await cursor.fetchall()\r\n            return [dict(row) for row in rows] if rows else []\r\n\r\n\r\nasync def get_blocks(course_id: int, current: bool = False) -> dict | int:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute('SELECT block_number, block_id FROM blocks WHERE course_id = ?', (course_id,))\r\n        rows = await cursor.fetchall()\r\n        if current:\r\n            if rows:\r\n                return max(int(x[0]) for x in rows)\r\n            else:\r\n                return 0\r\n        return {int(x[0]): int(x[1]) for x in rows}\r\n\r\n\r\nasync def get_course_id(course_title: str) -> int:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute('SELECT course_id FROM courses WHERE course_title=?', (course_title,))\r\n        course_id = await cursor.fetchone()\r\n        return course_id[0]\r\n\r\n\r\n# add_lesson\r\n# async def add_block(course_id: int, block_number: int) -> int:\r\n#     \"\"\"Если блока не существует, то добавляет его. Всегда возвращает id блока\"\"\"\r\n#     block_start = datetime.now().strftime(\"%Y-%m-%d\")\r\n#     async with aiosqlite.connect('educated_platform.db') as con:\r\n#         # Проверяем, существует ли блок\r\n#         if block_number not in await get_blocks(course_id):\r\n#             # Добавляем блок, если его нет\r\n#             await con.execute(\r\n#                 'INSERT INTO blocks (course_id, block_start, block_number) VALUES (?, ?, ?)',\r\n#                 (course_id, block_start, block_number)\r\n#             )\r\n#             await con.commit()\r\n#\r\n#         async with con.execute(\r\n#                 'SELECT block_id FROM blocks WHERE course_id = ? AND block_number = ?',\r\n#                 (course_id, block_number)) as cursor:\r\n#             row = await cursor.fetchone()\r\n#             return row[0]\r\n\r\nasync def check_block_exists(course_id: int, block_number: int) -> bool:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        async with con.execute(\r\n            '''SELECT b.block_id\r\n                FROM blocks b\r\n                WHERE b.course_id = ? AND b.block_number = ?\r\n            ''',\r\n            (course_id, block_number)\r\n        ) as cursor:\r\n            return await cursor.fetchall()\r\n\r\nasync def create_block(course_id: int, block_number: int) -> int:\r\n    \"\"\"Создает новый блок и возвращает его ID\"\"\"\r\n    block_start = datetime.now().strftime(\"%Y-%m-%d\")\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute(\r\n            'INSERT INTO blocks (course_id, block_start, block_number) VALUES (?, ?, ?)',\r\n            (course_id, block_start, block_number)\r\n        )\r\n        await con.commit()\r\n        return cursor.lastrowid\r\n\r\n# async def get_block_id(course_id: int, block_number: int) -> int:\r\n#     async with aiosqlite.connect('educated_platform.db') as con:\r\n#         async with con.execute(\r\n#             'SELECT block_id FROM blocks WHERE course_id = ? AND block_number = ?',\r\n#             (course_id, block_number)\r\n#         ) as cursor:\r\n#             row = await cursor.fetchone()\r\n#             return row[0] if row else None\r\n\r\n\r\nasync def add_task(task_title: str, block_id: int, verification: str, video_id: str, abstract_id: str,\r\n                   availability_files: bool, deadline: str) -> int:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        await con.execute(\r\n            'INSERT INTO tasks (task_title, block_id, verification, video_id, abstract_id, availability_files, deadline) VALUES(?, ?, ?, ?, ?, ?, ?)',\r\n            (task_title, block_id, verification, video_id, abstract_id, availability_files, deadline))\r\n        await con.commit()\r\n        task_id = await con.execute('SELECT task_id FROM tasks WHERE video_id = ?', (video_id,))\r\n        return (await task_id.fetchone())[0]\r\n\r\n\r\nasync def add_exercise(task_id: int, exercise_condition: str, exercise_answer=None) -> None:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        if exercise_answer is None:\r\n            await con.execute(\r\n                'INSERT INTO exercises (task_id, exercise_condition) VALUES(?, ?)',\r\n                (task_id, exercise_condition))\r\n        else:\r\n            await con.execute(\r\n                'INSERT INTO exercises (task_id, exercise_condition, exercise_answer) VALUES(?, ?, ?)',\r\n                (task_id, exercise_condition, exercise_answer))\r\n        await con.commit()\r\n\r\n\r\n# mapping lesson\r\nasync def get_list_exercises(task_id: int) -> dict:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute('SELECT verification FROM tasks WHERE task_id = ?', (task_id,))\r\n        verification_row = await cursor.fetchone()\r\n        verification = verification_row[0] if verification_row else None\r\n\r\n        if verification == 'Автоматическая проверка':\r\n            cursor = await con.execute(\r\n                'SELECT exercise_condition, exercise_answer, exercise_id FROM exercises WHERE task_id = ?',\r\n                (task_id,))\r\n            result = await cursor.fetchall()\r\n            return {num: (row[0], row[1], row[2]) for num, row in enumerate(result, 1)}\r\n        else:\r\n            cursor = await con.execute('SELECT exercise_condition, exercise_id FROM exercises WHERE task_id = ?',\r\n                                       (task_id,))\r\n            result = await cursor.fetchall()\r\n            return {num: (row[0], row[1]) for num, row in enumerate(result, 1)}\r\n\r\n\r\nasync def get_list_tasks(block_id: int) -> dict:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        async with con.cursor() as cursor:\r\n            cursor = await con.execute('SELECT task_title, task_id FROM tasks WHERE block_id=?',\r\n                                       (block_id,))\r\n            row = await cursor.fetchall()\r\n            if row:\r\n                return dict(row)\r\n            else:\r\n                return {}\r\n\r\n\r\nasync def mapping_task_status(user_id, task_id):\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = '''\r\n            SELECT \r\n                COUNT(e.exercise_id) as total_exercises,\r\n                SUM(lp.right_answer) as completed_exercises\r\n            FROM exercises e\r\n            LEFT JOIN learning_progress lp\r\n                ON e.exercise_id = lp.exercise_id\r\n                AND lp.user_id = ?\r\n            WHERE e.task_id = ?\r\n        '''\r\n        async with con.execute(query, (user_id, task_id)) as cursor:\r\n            result = await cursor.fetchone()\r\n\r\n            if not result or result['total_exercises'] == 0:\r\n                return '❌'\r\n\r\n            return '✅' if result['completed_exercises'] == result['total_exercises'] else '⏳'\r\n\r\n\r\nasync def get_data_task(task_id: int):\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = '''SELECT * FROM tasks WHERE task_id = ?'''\r\n        async with con.execute(query, (task_id,)) as cursor:\r\n            task_data = await cursor.fetchone()\r\n            return dict(task_data)\r\n\r\n\r\n# Recording response(answer) user\r\nasync def get_progress_user(task_id: int, session_id: int = None) -> dict:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n\r\n        query = \"\"\"\r\n        SELECT\r\n            e.exercise_id,\r\n            lp.input_answer,\r\n            lp.right_answer\r\n        FROM\r\n            learning_progress AS lp\r\n        JOIN\r\n            exercises AS e ON lp.exercise_id = e.exercise_id\r\n        WHERE\r\n            e.task_id = ?\r\n        \"\"\"\r\n\r\n        params = (task_id,)\r\n        if session_id is not None:\r\n            query += \" AND lp.session_id = ?\"\r\n            params += (session_id,)\r\n\r\n        async with con.execute(query, params) as cursor:\r\n            result = await cursor.fetchall()\r\n            if result:\r\n                return {row['exercise_id']: {'input_answer': row['input_answer'],\r\n                                             'status_input_answer': '✅' if row['right_answer'] else '❌'}\r\n                        for row in result}\r\n            else:\r\n                return {}\r\n\r\n\r\nasync def add_progress_user(user_id: int, task_id: int, homework: dict, results: dict, session_start: str,\r\n                            session_end: str, is_completed: bool = False) -> None:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute(\r\n            'INSERT INTO sessions (user_id, task_id, is_completed, session_start, session_end) VALUES (?, ?, ?, ?, ?)',\r\n            (user_id, task_id, is_completed, session_start, session_end)\r\n        )\r\n        session_id = cursor.lastrowid\r\n\r\n        for exercise_num in homework:\r\n            _, right_answer, exercise_id = homework[exercise_num]\r\n            input_answer = results.get(exercise_num, {}).get('input_answer', None)\r\n            if input_answer is not None:\r\n                is_correct = (str(input_answer).strip() == str(right_answer).strip())\r\n                await con.execute(\r\n                    'INSERT INTO learning_progress VALUES(?, ?, ?, ?, ?)',\r\n                    (user_id, exercise_id, input_answer, is_correct, session_id)\r\n                )\r\n        await con.commit()\r\n\r\n\r\nasync def get_last_session(user_id: int, task_id: int) -> dict:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = '''\r\n            SELECT *\r\n            FROM sessions\r\n            WHERE user_id = ? AND task_id = ?\r\n            ORDER BY session_id DESC\r\n            LIMIT 1\r\n        '''\r\n        async with con.execute(query, (user_id, task_id)) as cursor:\r\n            row = await cursor.fetchone()\r\n            return dict(row) if row else {}\r\n\r\n\r\nasync def get_timezones() -> dict:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = 'SELECT * FROM unique_timezones'\r\n        async with await con.execute(query) as cursor:\r\n            rows = await cursor.fetchall()\r\n            return {row[\"timezone_id\"]: row[\"timezone\"] for row in rows} if rows else {}\r\n\r\n\r\n# async def get_users_by_timezone(timezone_id: int) -> dict:\r\n#     async with aiosqlite.connect('educated_platform.db') as con:\r\n#         con.row_factory = aiosqlite.Row\r\n#         query = 'SELECT course_id, user_id FROM users WHERE timezone_id = ?'\r\n#         async with con.execute(query, (timezone_id,)) as cursor:\r\n#             rows = await cursor.fetchall()\r\n#             result = defaultdict(list)\r\n#             for row in rows:\r\n#                 result[row[\"course_id\"]].append(row[\"user_id\"])\r\n#             return dict(result)\r\n#\r\n#\r\n\r\n\r\nasync def get_due_tasks_for_timezone(timezone_id: int, current_date: str) -> list:\r\n    \"\"\"\r\n    Возвращает список строк, где каждая строка содержит:\r\n      - user_id: идентификатор пользователя\r\n      - task_id: идентификатор задания\r\n      - actual_deadline: дедлайн, учитывающий changed_deadlines\r\n      - is_completed: статус завершения сессии (может быть None, если сессии нет)\r\n    Для заданий, дедлайн которых равен current_date,\r\n    и пользователей с заданным timezone_id.\r\n    Возвращает только тех пользователей, у которых нет сессий с is_completed = 1.\r\n    \"\"\"\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = \"\"\"SELECT\r\n                u.user_id,\r\n                t.task_id,\r\n                u.lives\r\n            FROM tasks t\r\n            JOIN blocks b ON b.block_id = t.block_id\r\n            JOIN users u ON u.course_id = b.course_id\r\n            LEFT JOIN changed_deadlines cd ON cd.task_id = t.task_id AND cd.user_id = u.user_id\r\n            LEFT JOIN sessions s ON s.task_id = t.task_id AND s.user_id = u.user_id\r\n            WHERE u.timezone_id = ?\r\n              AND COALESCE(cd.deadline, t.deadline) = ?\r\n            GROUP BY u.user_id, t.task_id\r\n            HAVING MAX(s.is_completed) IS NULL OR MAX(s.is_completed) = 0\r\n                    \"\"\"\r\n\r\n        async with con.execute(query, (timezone_id, current_date)) as cursor:\r\n            rows = await cursor.fetchall()\r\n            return [dict(row) for row in rows] if rows else []\r\n\r\n\r\n\r\nasync def update_deadlines_and_lives_bulk(updates: list, timezone_id: int) -> None:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        # Получаем значение timezone из unique_timezones\r\n        async with con.execute(\"SELECT timezone FROM unique_timezones WHERE timezone_id = ?\", (timezone_id,)) as cur:\r\n            row = await cur.fetchone()\r\n            if not row:\r\n                raise ValueError(f\"Timezone with id {timezone_id} not found\")\r\n            tz_value = str(row[0])\r\n\r\n        # Вычисляем новый дедлайн как завтрашнюю дату с учетом timezone\r\n        new_deadline = (datetime.now(tz=ZoneInfo(tz_value)) + timedelta(days=1)).strftime(\"%Y-%m-%d %H:%M:%S\")\r\n\r\n        await con.execute(\"BEGIN TRANSACTION\")\r\n        try:\r\n            # Группируем уникальные пары (user_id, task_id)\r\n            unique_pairs = {(u[\"user_id\"], u[\"task_id\"]) for u in updates}\r\n\r\n            # Обновляем дедлайны в changed_deadlines с использованием UPSERT\r\n            await con.executemany(\r\n                \"\"\"INSERT INTO changed_deadlines (user_id, task_id, deadline)\r\n                   VALUES (?, ?, ?)\r\n                   ON CONFLICT(user_id, task_id) \r\n                   DO UPDATE SET deadline = excluded.deadline\"\"\",\r\n                [(user_id, task_id, new_deadline) for user_id, task_id in unique_pairs]\r\n            )\r\n\r\n            # Считаем количество списаний для каждого пользователя\r\n            user_counts = defaultdict(int)\r\n            for u in updates:\r\n                user_counts[u[\"user_id\"]] += 1\r\n\r\n            # Обновляем жизни для каждого пользователя\r\n            await con.executemany(\r\n                \"\"\"UPDATE users \r\n                   SET lives = MAX(lives - ?, 0)\r\n                   WHERE user_id = ?\"\"\",\r\n                [(count, user_id) for user_id, count in user_counts.items()]\r\n            )\r\n\r\n            # Готовим записи для истории списаний.\r\n            # Предполагаем, что в updates для каждого пользователя поле \"lives\" содержит текущее значение до списания.\r\n            history_records = []\r\n            for u in updates:\r\n                # Если один пользователь появляется несколько раз, мы будем добавлять несколько записей.\r\n                new_lives = u[\"lives\"] - user_counts[u[\"user_id\"]]\r\n                history_records.append((u[\"user_id\"], u[\"task_id\"], new_lives))\r\n\r\n            # Выполняем пакетную вставку в history_of_lives\r\n            await con.executemany(\r\n                \"INSERT INTO history_of_lives (user_id, task_id, current_lives) VALUES (?, ?, ?)\",\r\n                history_records\r\n            )\r\n\r\n            await con.commit()\r\n\r\n        except Exception as e:\r\n            await con.rollback()\r\n            raise e\r\n\r\n\r\nasync def get_today_deadline(user_id: int | None = None, timezone_id: int | None = None) -> None | list:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        if user_id:\r\n            current_deadline = datetime.now().strftime(\"%Y-%m-%d\")\r\n            query = '''SELECT t.task_title, u.lives\r\n                           FROM tasks t \r\n                           JOIN blocks b ON b.block_id = t.block_id\r\n                           JOIN users u ON b.course_id = u.course_id\r\n                           WHERE u.user_id = ? AND t.deadline = ? \r\n                           '''\r\n            con.row_factory = aiosqlite.Row\r\n            async with con.execute(query, (user_id, current_deadline)) as cursor:\r\n                rows = await cursor.fetchall()\r\n                return [dict(row) for row in rows] if rows else []\r\n        elif timezone_id:\r\n            query = '''SELECT u.user_id, u.course_id, t.task_id, t.task_title, b.block_id\r\n                       FROM tasks t\r\n                       JOIN blocks b ON b.block_id = t.block_id\r\n                       JOIN users u ON u.course_id = b.block_id\r\n                       WHERE u.timezone_id = ?'''\r\n            con.row_factory = aiosqlite.Row\r\n            async with con.execute(query, (timezone_id,)) as cursor:\r\n                rows = await cursor.fetchall()\r\n                return [dict(row) for row in rows] if rows else []\r\n\r\n\r\nasync def get_today_new_block() -> list:\r\n    current_date = datetime.now().strftime(\"%Y-%m-%d\")\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute('SELECT course_id FROM blocks WHERE block_start=?', current_date)\r\n        rows = await cursor.fetchall()\r\n        return [row[0] for row in rows] if rows else []\r\n\r\n\r\nasync def update_info_with_new_block(course_id, block_id):\r\n    current_date = datetime.now().strftime(\"%Y-%m-%d\")\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute('SELECT course_id FROM blocks WHERE block_start=?', current_date)\r\n        rows = await cursor.fetchall()\r\n        new_block_today = [row[0] for row in rows] if rows else []\r\n        if new_block_today:\r\n            await con.execute(\"BEGIN TRANSACTION\")\r\n\r\n\r\n\r\n# async def get_list_lives(user)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/database.py b/database.py
--- a/database.py	(revision b0591667e66263e7d38695590eb03be98f9ba183)
+++ b/database.py	(date 1742544483686)
@@ -43,7 +43,6 @@
         await con.execute('''CREATE TABLE IF NOT EXISTS blocks (
             course_id INTEGER,
             block_number INTEGER, 
-            block_start TEXT,
             block_id INTEGER PRIMARY KEY AUTOINCREMENT)''')
 
         await con.execute('''CREATE TABLE IF NOT EXISTS tasks (
@@ -90,20 +89,20 @@
         await con.execute('''CREATE TABLE IF NOT EXISTS history_of_lives (
             user_id INTEGER,
             task_id INTEGER,
-            current_lives INTEGER)''')
+            lives_after_action INTEGER,
+            action TEXT)''')  # action: +1, +3, -1...
 
         await con.commit()
 
 
 # Registration
 async def create_course(course_title) -> None:
-    block_start = datetime.now().strftime("%Y-%m-%d")
     async with aiosqlite.connect('educated_platform.db') as con:
         await con.execute('INSERT INTO courses (course_title) VALUES(?)', (course_title,))
         await con.commit()
         course_id = await get_course_id(course_title)
-        await con.execute('INSERT INTO blocks (course_id, block_start, block_number) VALUES(?, ?, ?)',
-                          (course_id, block_start, 1))
+        await con.execute('INSERT INTO blocks (course_id, block_number) VALUES(?, ?)',
+                          (course_id, 1))
         await con.commit()
 
 
@@ -143,12 +142,20 @@
         if course_id:
             await con.execute('INSERT INTO users VALUES (?, ?, ?, ?, ?, ?, ?)',
                               (username, user_id, course_id[0], timezone_id, date_of_joining, lives, role))
+            await con.execute('INSERT INTO history_of_lives VALUES(?, ?, ?, ?)', (user_id, None, None, '+3'))
             await con.execute('DELETE FROM unregistered WHERE username = ?', (username,))
             await con.commit()
         return course_id
 
 
 # Other function
+async def get_users_by_course(course_id: int) -> list:
+    async with aiosqlite.connect('educated_platform.db') as con:
+        cursor = await con.execute('SELECT user_id FROM users WHERE course_id=? AND role = ?', (course_id, 'student'))
+        result = await cursor.fetchall()
+        return [x[0] for x in result] if result else []
+
+
 async def get_data_user(user_id: int) -> dict:
     async with aiosqlite.connect('educated_platform.db') as con:
         con.row_factory = aiosqlite.Row
@@ -190,57 +197,29 @@
         return course_id[0]
 
 
-# add_lesson
-# async def add_block(course_id: int, block_number: int) -> int:
-#     """Если блока не существует, то добавляет его. Всегда возвращает id блока"""
-#     block_start = datetime.now().strftime("%Y-%m-%d")
-#     async with aiosqlite.connect('educated_platform.db') as con:
-#         # Проверяем, существует ли блок
-#         if block_number not in await get_blocks(course_id):
-#             # Добавляем блок, если его нет
-#             await con.execute(
-#                 'INSERT INTO blocks (course_id, block_start, block_number) VALUES (?, ?, ?)',
-#                 (course_id, block_start, block_number)
-#             )
-#             await con.commit()
-#
-#         async with con.execute(
-#                 'SELECT block_id FROM blocks WHERE course_id = ? AND block_number = ?',
-#                 (course_id, block_number)) as cursor:
-#             row = await cursor.fetchone()
-#             return row[0]
-
-async def check_block_exists(course_id: int, block_number: int) -> bool:
+async def check_block_exists(course_id: int, block_number: int) -> int:
     async with aiosqlite.connect('educated_platform.db') as con:
         async with con.execute(
-            '''SELECT b.block_id
-                FROM blocks b
-                WHERE b.course_id = ? AND b.block_number = ?
-            ''',
-            (course_id, block_number)
+                '''SELECT b.block_id
+                    FROM blocks b
+                    WHERE b.course_id = ? AND b.block_number = ?
+                ''',
+                (course_id, block_number)
         ) as cursor:
-            return await cursor.fetchall()
+            result = await cursor.fetchall()
+            return int(result[0][0]) if result else None
+
 
 async def create_block(course_id: int, block_number: int) -> int:
     """Создает новый блок и возвращает его ID"""
-    block_start = datetime.now().strftime("%Y-%m-%d")
     async with aiosqlite.connect('educated_platform.db') as con:
         cursor = await con.execute(
-            'INSERT INTO blocks (course_id, block_start, block_number) VALUES (?, ?, ?)',
-            (course_id, block_start, block_number)
+            'INSERT INTO blocks (course_id, block_number) VALUES (?, ?)',
+            (course_id, block_number)
         )
         await con.commit()
         return cursor.lastrowid
 
-# async def get_block_id(course_id: int, block_number: int) -> int:
-#     async with aiosqlite.connect('educated_platform.db') as con:
-#         async with con.execute(
-#             'SELECT block_id FROM blocks WHERE course_id = ? AND block_number = ?',
-#             (course_id, block_number)
-#         ) as cursor:
-#             row = await cursor.fetchone()
-#             return row[0] if row else None
-
 
 async def add_task(task_title: str, block_id: int, verification: str, video_id: str, abstract_id: str,
                    availability_files: bool, deadline: str) -> int:
@@ -299,26 +278,62 @@
                 return {}
 
 
-async def mapping_task_status(user_id, task_id):
+from datetime import datetime
+
+
+async def mapping_task_status(user_id: int, task_id: int) -> str:
     async with aiosqlite.connect('educated_platform.db') as con:
         con.row_factory = aiosqlite.Row
         query = '''
             SELECT 
-                COUNT(e.exercise_id) as total_exercises,
-                SUM(lp.right_answer) as completed_exercises
-            FROM exercises e
+                COUNT(e.exercise_id) AS total_exercises,
+                SUM(lp.right_answer) AS completed_exercises,
+                COALESCE(cd.deadline, t.deadline) AS deadline
+            FROM tasks t
+            JOIN exercises e 
+                ON t.task_id = e.task_id
+            LEFT JOIN changed_deadlines cd 
+                ON cd.task_id = t.task_id
+               AND cd.user_id = ?
             LEFT JOIN learning_progress lp
-                ON e.exercise_id = lp.exercise_id
-                AND lp.user_id = ?
-            WHERE e.task_id = ?
+                ON lp.exercise_id = e.exercise_id
+               AND lp.user_id = ?
+            WHERE t.task_id = ?
         '''
-        async with con.execute(query, (user_id, task_id)) as cursor:
-            result = await cursor.fetchone()
+        async with con.execute(query, (user_id, user_id, task_id)) as cursor:
+            row = await cursor.fetchone()
+
+            if not row or row['total_exercises'] == 0:
+                return '❌'
 
-            if not result or result['total_exercises'] == 0:
+            total_exercises = row['total_exercises']
+            completed_exercises = row['completed_exercises'] or 0
+            deadline_str = row['deadline']
+
+            # Парсим дедлайн с учетом того, что он может содержать только дату
+            deadline = None
+            if deadline_str:
+                try:
+                    # Если строка содержит только дату (YYYY-MM-DD)
+                    if len(deadline_str) == 10:
+                        deadline = datetime.strptime(deadline_str, '%Y-%m-%d')
+                    else:
+                        deadline = datetime.strptime(deadline_str, '%Y-%m-%d %H:%M:%S')
+                except ValueError:
+                    # Если формат не соответствует ни одному из ожидаемых вариантов,
+                    # можно залогировать ошибку или задать deadline = None
+                    deadline = None
+
+            # Если дедлайн задан и прошёл, и не все упражнения выполнены до дедлайна – возвращаем ❌
+            if deadline and datetime.now() > deadline and completed_exercises < total_exercises:
                 return '❌'
 
-            return '✅' if result['completed_exercises'] == result['total_exercises'] else '⏳'
+            # Если все упражнения выполнены – возвращаем ✅
+            if completed_exercises == total_exercises:
+                return '✅'
+
+            # Иначе возвращаем статус "в процессе" – ⏳
+            return '⏳'
 
 
 async def get_data_task(task_id: int):
@@ -408,20 +423,6 @@
             return {row["timezone_id"]: row["timezone"] for row in rows} if rows else {}
 
 
-# async def get_users_by_timezone(timezone_id: int) -> dict:
-#     async with aiosqlite.connect('educated_platform.db') as con:
-#         con.row_factory = aiosqlite.Row
-#         query = 'SELECT course_id, user_id FROM users WHERE timezone_id = ?'
-#         async with con.execute(query, (timezone_id,)) as cursor:
-#             rows = await cursor.fetchall()
-#             result = defaultdict(list)
-#             for row in rows:
-#                 result[row["course_id"]].append(row["user_id"])
-#             return dict(result)
-#
-#
-
-
 async def get_due_tasks_for_timezone(timezone_id: int, current_date: str) -> list:
     """
     Возвращает список строк, где каждая строка содержит:
@@ -455,7 +456,6 @@
             return [dict(row) for row in rows] if rows else []
 
 
-
 async def update_deadlines_and_lives_bulk(updates: list, timezone_id: int) -> None:
     async with aiosqlite.connect('educated_platform.db') as con:
         # Получаем значение timezone из unique_timezones
@@ -501,11 +501,11 @@
             for u in updates:
                 # Если один пользователь появляется несколько раз, мы будем добавлять несколько записей.
                 new_lives = u["lives"] - user_counts[u["user_id"]]
-                history_records.append((u["user_id"], u["task_id"], new_lives))
+                history_records.append((u["user_id"], u["task_id"], new_lives, '-1'))
 
             # Выполняем пакетную вставку в history_of_lives
             await con.executemany(
-                "INSERT INTO history_of_lives (user_id, task_id, current_lives) VALUES (?, ?, ?)",
+                "INSERT INTO history_of_lives VALUES (?, ?, ?, ?)",
                 history_records
             )
 
@@ -550,15 +550,25 @@
         return [row[0] for row in rows] if rows else []
 
 
-async def update_info_with_new_block(course_id, block_id):
-    current_date = datetime.now().strftime("%Y-%m-%d")
+async def update_lives(course_id):
+    async with aiosqlite.connect('educated_platform.db') as con:
+        await con.execute('UPDATE users SET lives = ? WHERE course_id = ? AND lives != ?', (3, course_id, 0))
+        await con.execute('''
+                   DELETE FROM history_of_lives
+                   WHERE user_id IN (
+                       SELECT user_id FROM users WHERE course_id = ?
+                   )''', (course_id,))
+        await con.execute('INSERT INTO history_of_lives VALUES(?, ?, ?, ?)', ('all_users', None, 3, '+3'))
+        await con.commit()
+
+
+async def get_history_lives_user(user_id: int) -> list:
     async with aiosqlite.connect('educated_platform.db') as con:
-        cursor = await con.execute('SELECT course_id FROM blocks WHERE block_start=?', current_date)
-        rows = await cursor.fetchall()
-        new_block_today = [row[0] for row in rows] if rows else []
-        if new_block_today:
-            await con.execute("BEGIN TRANSACTION")
-
-
-
-# async def get_list_lives(user)
\ No newline at end of file
+        con.row_factory = aiosqlite.Row
+        query = '''SELECT h.lives_after_action, h.action, t.task_title
+                   FROM history_of_lives h
+                   LEFT JOIN tasks t ON t.task_id = h.task_id
+                   WHERE h.user_id = ? OR h.user_id = ?'''
+        async with con.execute(query, (user_id, 'all_users')) as cursor:
+            result = await cursor.fetchall()
+            return [dict(x) for x in result] if result else []
Index: registration.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from aiogram.types import Message\r\nfrom aiogram.fsm.context import FSMContext\r\nfrom aiogram import Router\r\nfrom timezonefinder import TimezoneFinder\r\nfrom geopy.geocoders import Nominatim\r\nimport state as st\r\nimport database as db\r\nimport keyboard as kb\r\nfrom handlers.command import command_menu\r\n\r\nrouter = Router()\r\n\r\n\r\n@router.message(st.Registration.get_name_user)\r\nasync def getting_name_user(message: Message, state: FSMContext):\r\n    name_user = message.text\r\n    await state.update_data(name_user=name_user)\r\n    await message.answer(\r\n        'Теперь отправь мне свою локацию или название ближайшего большого города. Это нужно для корректного отображения дедлайнов',\r\n        reply_markup=kb.location_button)\r\n    await state.set_state(st.Registration.get_location_user)\r\n\r\n\r\n@router.message(st.Registration.get_location_user)\r\nasync def registration_user(message: Message, state: FSMContext):\r\n    data = await state.get_data()\r\n    latitude, longitude = None, None\r\n    # Если пользователь отправил геолокацию, используем её\r\n    if message.location:\r\n        latitude = message.location.latitude\r\n        longitude = message.location.longitude\r\n    # Если отправлен текст, считаем, что это название города и проводим геокодинг\r\n    elif message.text:\r\n        geolocator = Nominatim(user_agent=\"timezone_app\")\r\n        location = geolocator.geocode(message.text)\r\n        if location is None:\r\n            await message.answer(\"Город не найден. Пожалуйста, проверьте название и попробуйте еще раз.\")\r\n            return\r\n        latitude = location.latitude\r\n        longitude = location.longitude\r\n    else:\r\n        await message.answer(\"Пожалуйста, отправьте название города или свою геолокацию.\")\r\n        return\r\n\r\n    # Определяем часовой пояс по координатам\r\n    tf = TimezoneFinder()\r\n    timezone_name = tf.timezone_at(lat=latitude, lng=longitude)\r\n    if timezone_name is None:\r\n        await message.answer(\"Не удалось определить часовой пояс по указанным данным. Попробуйте снова.\")\r\n        return\r\n    role = 'student' if message.from_user.id != 795508218 else 'admin'\r\n    # Регистрируем пользователя в базе данных\r\n    result = await db.registration_user(data['name_user'], message.from_user.id, timezone_name, role)\r\n    if result:\r\n        text_message, keyboard = await kb.send_command_menu(message.from_user.id)\r\n        message_menu_id = await message.answer(text_message, reply_markup=keyboard)\r\n        if role == 'student':\r\n            await state.set_state(st.MappingExercise.mapping_command_menu)\r\n            await state.update_data(message_menu_id=message_menu_id)\r\n    else:\r\n        await message.answer(\r\n            'Ты не был добавлен админом на курс, попробуй проверить введенные данные или обратиться к администратору :(')\r\n        await state.clear()\r\n        await state.set_state(st.Registration.get_name_user)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/registration.py b/registration.py
--- a/registration.py	(revision b0591667e66263e7d38695590eb03be98f9ba183)
+++ b/registration.py	(date 1742544483810)
@@ -48,7 +48,7 @@
     if timezone_name is None:
         await message.answer("Не удалось определить часовой пояс по указанным данным. Попробуйте снова.")
         return
-    role = 'student' if message.from_user.id != 795508218 else 'admin'
+    role = 'student' #if message.from_user.id != 795508218 else 'admin'
     # Регистрируем пользователя в базе данных
     result = await db.registration_user(data['name_user'], message.from_user.id, timezone_name, role)
     if result:
Index: keyboard.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from aiogram.fsm.context import FSMContext\r\nfrom aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, Message\r\n\r\nimport database as db\r\nimport state as st\r\nfrom aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder\r\nimport calendar\r\n\r\n\r\nasync def mapping_block_list(course_id: int):\r\n    data = await db.get_blocks(course_id)\r\n    builder = InlineKeyboardBuilder()\r\n    for block in data:\r\n        builder.row(InlineKeyboardButton(text=f'{block} блок', callback_data=f'open_block:{course_id}:{data[block]}'))\r\n    builder.row(*[InlineKeyboardButton(text='Назад', callback_data='back_student')])\r\n    return builder.as_markup()\r\n\r\n\r\nasync def mapping_list_tasks(user_id: int, course_id: int, block_id: int) -> InlineKeyboardMarkup:\r\n    builder = InlineKeyboardBuilder()\r\n    tasks = await db.get_list_tasks(block_id)\r\n    for task_title in tasks:\r\n        task_id = tasks[task_title]\r\n        task_status = await db.mapping_task_status(user_id, task_id)\r\n        builder.row(\r\n            *[InlineKeyboardButton(text=f'{task_title}{task_status}',\r\n                                   callback_data=f'open_task:{course_id}:{task_id}')])\r\n    return builder.as_markup()\r\n\r\n\r\nasync def mapping_homework(quantity_exercise: int, current_exercise: int) -> InlineKeyboardMarkup:\r\n    builder = InlineKeyboardBuilder()\r\n    if current_exercise == 1:\r\n        builder.add(\r\n            InlineKeyboardButton(text=f'{current_exercise}/{quantity_exercise}', callback_data='open_list_exercises'),\r\n            InlineKeyboardButton(text='\\u2192', callback_data=f'next_exercise:{current_exercise + 1}'))\r\n        builder.adjust(2)\r\n    elif current_exercise == quantity_exercise:\r\n        builder.add(InlineKeyboardButton(text=\"\\u2190\", callback_data=f'prev_exercise:{current_exercise - 1}'),\r\n                    InlineKeyboardButton(text=f'{current_exercise}/{quantity_exercise}',\r\n                                         callback_data='open_list_exercises'))\r\n        builder.adjust(2)\r\n    else:\r\n        builder.add(\r\n            InlineKeyboardButton(text=\"\\u2190\", callback_data=f'prev_exercise:{current_exercise - 1}'),\r\n            InlineKeyboardButton(text=f'{current_exercise}/{quantity_exercise}', callback_data='open_list_exercises'),\r\n            InlineKeyboardButton(text='\\u2192', callback_data=f'next_exercise:{current_exercise + 1}'))\r\n        builder.adjust(3)\r\n    builder.row(*[InlineKeyboardButton(text='Завершить выполнение работы', callback_data='complete_homework')])\r\n    return builder.as_markup()\r\n\r\n\r\nasync def mapping_task(course_id, block_id, abstract_retrieved: bool = False) -> InlineKeyboardMarkup:\r\n    keyboard_buttons = [\r\n        [InlineKeyboardButton(text='Домашняя работа', callback_data='open_homework')]\r\n    ]\r\n    if not abstract_retrieved:\r\n        keyboard_buttons.append(\r\n            [InlineKeyboardButton(text='Конспект урока', callback_data='get_abstract')]\r\n        )\r\n    keyboard_buttons.append([\r\n        InlineKeyboardButton(text='Назад', callback_data=f'open_block_from_homework:{course_id}:{block_id}'),\r\n        InlineKeyboardButton(text='В главное меню', callback_data='back_student')\r\n    ])\r\n    return InlineKeyboardMarkup(inline_keyboard=keyboard_buttons)\r\n\r\n\r\nasync def mapping_list_exercises(state_data: dict, decides: bool) -> InlineKeyboardMarkup:\r\n    builder = InlineKeyboardBuilder()\r\n    task_id = state_data['task_data']['task_id']\r\n    homework = state_data['homework']\r\n    if decides:\r\n        results = state_data.get('results', {})\r\n        for exercise_number in homework:\r\n            result_status = results.get(exercise_number, {}).get('status_input_answer', '⌛')\r\n            builder.add(InlineKeyboardButton(\r\n                text=f'{exercise_number} задание {result_status}',\r\n                callback_data=f'open_exercise:{exercise_number}'\r\n            ))\r\n    else:\r\n        progress_solving = await db.get_progress_user(task_id)\r\n        for exercise_number in homework:\r\n            if exercise_number in progress_solving:\r\n                status = '⌛' if progress_solving[exercise_number]['input_answer'] is None else \\\r\n                    progress_solving[exercise_number]['exercise_status']\r\n            else:\r\n                status = '⌛'  # Или любой другой значок, если данных нет\r\n\r\n            builder.add(InlineKeyboardButton(\r\n                text=f'{exercise_number} задание {status}',\r\n                callback_data=f'open_exercise:{exercise_number}'\r\n            ))\r\n\r\n    builder.adjust(1)\r\n    return builder.as_markup()\r\n\r\n\r\nasync def choose_parameters_task(deadline) -> InlineKeyboardMarkup:\r\n    keyboard = InlineKeyboardMarkup(\r\n        inline_keyboard=[[InlineKeyboardButton(text='Автоматическая проверка', callback_data=f'verif:auto:{deadline}'),\r\n                          InlineKeyboardButton(text='Ручная проверка', callback_data=f'verif:manual:{deadline}')]\r\n                         ])\r\n    return keyboard\r\n\r\n\r\nasync def generate_calendar(year: int, month: int) -> InlineKeyboardMarkup:\r\n    builder = InlineKeyboardBuilder()\r\n    builder.row(\r\n        InlineKeyboardButton(text=\"\\u2190\", callback_data=f\"prev_month:{year}:{month}\"),\r\n        InlineKeyboardButton(text=f\"{year}, {calendar.month_name[month]}\", callback_data=\"ignore\"),\r\n        InlineKeyboardButton(text=\"\\u2192\", callback_data=f\"next_month:{year}:{month}\")\r\n    )\r\n    day_names = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс']\r\n    builder.row(*[InlineKeyboardButton(text=day, callback_data='ignore') for day in day_names])\r\n    month_calendar = calendar.monthcalendar(year, month)\r\n    for week in month_calendar:\r\n        builder.row(*[\r\n            InlineKeyboardButton(text=str(day) if day != 0 else ' ',\r\n                                 callback_data=f'select_day:{year}:{month}:{day}')\r\n            for day in week])\r\n    return builder.as_markup()\r\n\r\n\r\nasync def to_change_block(current_block):\r\n    change_block_buttons = InlineKeyboardMarkup(inline_keyboard=[\r\n        [InlineKeyboardButton(text='Предыдущий блок', callback_data=f'reduce_block:{current_block}'),\r\n         InlineKeyboardButton(text='Следующий блок', callback_data=f'increase_block:{current_block}')],\r\n        [InlineKeyboardButton(text='Подтвердить выбор', callback_data=f'confirm_block:{current_block}')],\r\n        [InlineKeyboardButton(text='Назад', callback_data='back_admin')]\r\n    ])\r\n    return change_block_buttons\r\n\r\n\r\nasync def choose_course_inline():\r\n    \"\"\"Используется для добавления задания\"\"\"\r\n    builder = InlineKeyboardBuilder()\r\n    courses = await db.get_list_courses()\r\n    for course in courses:\r\n        builder.add(InlineKeyboardButton(text=course['course_title'], callback_data=f\"choose_course:{course['course_title']}\"))\r\n\r\n    return builder.as_markup(resize_keyboard=True, one_time_keyboard=True)\r\n\r\n\r\nasync def choose_course_reply():\r\n    \"\"\"Используется для добавления списка пользователей\"\"\"\r\n    builder = ReplyKeyboardBuilder()\r\n    courses = await db.get_list_courses()\r\n    builder.add(KeyboardButton(text='Создать новый'))\r\n    for course in courses:\r\n        builder.add(KeyboardButton(text=course['task_title']))\r\n    builder.adjust(2)\r\n    return builder.as_markup(resize_keyboard=True, one_time_keyboard=True)\r\n\r\n\r\nasync def send_command_menu(user_id: int):\r\n    user_data = await db.get_data_user(user_id)\r\n    if user_data['role'] == 'student':\r\n        command_menu = InlineKeyboardMarkup(inline_keyboard=[\r\n            [InlineKeyboardButton(text='Список занятий', callback_data='block_list')],\r\n            [InlineKeyboardButton(text='Открыть последнее занятие', callback_data='last_lesson')],\r\n            [InlineKeyboardButton(text='Посмотреть историю жизней', callback_data='list_lives')],\r\n        ])\r\n        lives = user_data['lives']\r\n        deadline_today = await db.get_today_deadline(user_id)\r\n        text_message = f'Текущее количество жизней: {lives * '❤\uFE0F'}\\n'\r\n        if deadline_today:\r\n            text_message += f'Дедлайны сегодня: {', '.join(task['task_title'] for task in deadline_today)}'\r\n        else:\r\n            text_message += 'Дедлайны сегодня: -'\r\n        return text_message, command_menu\r\n    elif user_data['role'] == 'admin':\r\n        command_menu = InlineKeyboardMarkup(inline_keyboard=[\r\n            [InlineKeyboardButton(text='Добавить урок', callback_data='add_lesson')],\r\n            [InlineKeyboardButton(text='Добвить пользователей', callback_data='add_users')]\r\n        ])\r\n        text_message = 'Распознал тебя как админа'\r\n        return text_message, command_menu\r\n\r\n\r\nasync def start_the_task_from_the_reminder(course_id: int, task_id: int) -> InlineKeyboardMarkup:\r\n    button = InlineKeyboardMarkup(inline_keyboard=[\r\n        [InlineKeyboardButton(text='Приступить к выполнению задания', callback_data=f'open_task:{course_id}:{task_id}')]\r\n    ])\r\n    # await state.set_state(st.MappingExercise.mapping_task)\r\n    # await state.update_data(course_id=course_id, block_id=block_id)\r\n    return button\r\n\r\n\r\nback_button_student = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Назад', callback_data='back_student')]\r\n])\r\n\r\nback_button_admin = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Назад', callback_data='back_admin')]\r\n])\r\n\r\nsend_homework_keyboard = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Редактировать введённые данные', callback_data='change_homework')],\r\n    [InlineKeyboardButton(text='Отправить домашнюю работу', callback_data='send_homework')]\r\n])\r\n\r\navailability_files_task = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Нет', callback_data='availability_files:Нет'),\r\n     InlineKeyboardButton(text='Да', callback_data='availability_files:Да')]\r\n])\r\n\r\nconfirm_task = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Редактировать', callback_data='finish_task:edit_task'),\r\n     InlineKeyboardButton(text='Подтвердить', callback_data='finish_task:confirm_task')]\r\n])\r\n\r\nsend_exercise = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Отправить данные из таблицы в базу данных', callback_data='send_exercise')]\r\n])\r\n\r\nlocation_button = ReplyKeyboardMarkup(\r\n    keyboard=[\r\n        [KeyboardButton(text=\"\uD83D\uDCCD Отправить геолокацию\", request_location=True)]\r\n    ],\r\n    resize_keyboard=True,\r\n    one_time_keyboard=True\r\n)\r\n\r\n\r\nconfirm_new_block_keyboard = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Отменить', callback_data='cancel_update_block'),\r\n     InlineKeyboardButton(text='Подтвердить', callback_data='confirm_new_block')]\r\n])\r\n\r\n\r\nconfirm_new_block_keyboard = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Отменить', callback_data='cancel_update_block'),\r\n     InlineKeyboardButton(text='Подтвердить', callback_data='confirm_new_block')]\r\n])
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/keyboard.py b/keyboard.py
--- a/keyboard.py	(revision b0591667e66263e7d38695590eb03be98f9ba183)
+++ b/keyboard.py	(date 1742544483809)
@@ -1,8 +1,6 @@
-from aiogram.fsm.context import FSMContext
 from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, Message
 
 import database as db
-import state as st
 from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder
 import calendar
 
@@ -147,7 +145,7 @@
     courses = await db.get_list_courses()
     builder.add(KeyboardButton(text='Создать новый'))
     for course in courses:
-        builder.add(KeyboardButton(text=course['task_title']))
+        builder.add(KeyboardButton(text=course['course_title']))
     builder.adjust(2)
     return builder.as_markup(resize_keyboard=True, one_time_keyboard=True)
 
@@ -181,8 +179,6 @@
     button = InlineKeyboardMarkup(inline_keyboard=[
         [InlineKeyboardButton(text='Приступить к выполнению задания', callback_data=f'open_task:{course_id}:{task_id}')]
     ])
-    # await state.set_state(st.MappingExercise.mapping_task)
-    # await state.update_data(course_id=course_id, block_id=block_id)
     return button
 
 
@@ -226,9 +222,3 @@
     [InlineKeyboardButton(text='Отменить', callback_data='cancel_update_block'),
      InlineKeyboardButton(text='Подтвердить', callback_data='confirm_new_block')]
 ])
-
-
-confirm_new_block_keyboard = InlineKeyboardMarkup(inline_keyboard=[
-    [InlineKeyboardButton(text='Отменить', callback_data='cancel_update_block'),
-     InlineKeyboardButton(text='Подтвердить', callback_data='confirm_new_block')]
-])
\ No newline at end of file
Index: callbacks/create_task.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from aiogram.fsm.context import FSMContext\r\nfrom aiogram.types import CallbackQuery, InputMediaVideo\r\nfrom aiogram import Router, F\r\nfrom datetime import datetime\r\nfrom google_table import get_exersice\r\n\r\nimport calendar\r\nimport state as st\r\nimport database as db\r\nimport keyboard as kb\r\n\r\nrouter = Router()\r\n\r\n\r\n@router.callback_query(F.data == 'add_users')\r\nasync def process_add_users(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    await callback_query.message.answer('Выбери курс', reply_markup=await kb.choose_course_reply())\r\n    await state.set_state(st.AddUsers.choose_course)\r\n\r\n\r\n@router.callback_query(F.data == 'add_lesson')\r\nasync def process_add_lesson(callback_query: CallbackQuery):\r\n    await callback_query.answer()\r\n    await callback_query.message.edit_text(f'Для добавления домашнего задания выбери курс',\r\n                                           reply_markup=await kb.choose_course_inline())\r\n\r\n\r\n@router.callback_query(lambda c: c.data.startswith('choose_course'))\r\nasync def process_increase_block(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    await state.set_state(st.AddTask.choose_course)\r\n    course_name = callback_query.data.split(\":\")[-1]\r\n    course_id = await db.get_course_id(course_name)\r\n    current_block = await db.get_blocks(course_id, current=True)\r\n    await state.update_data(course_id=course_id, current_block=current_block)\r\n    await callback_query.message.edit_text(\r\n        f'Выбери блок\\n\\nТекущий выбор: {current_block} блок',\r\n        reply_markup=await kb.to_change_block(current_block))\r\n\r\n\r\n@router.callback_query(\r\n    lambda c: c.data.startswith(\"increase_block\") or c.data.startswith(\"reduce_block\") or c.data.startswith(\r\n        \"confirm_block\"))\r\nasync def process_increase_block(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n\r\n    action, current_value = callback_query.data.split(\":\")\r\n    selected_block = int(current_value)\r\n    if action == \"increase_block\":\r\n        selected_block += 1\r\n    elif action == \"reduce_block\" and selected_block != 1:\r\n        selected_block -= 1\r\n    elif action == 'confirm_block':\r\n        state_data = await state.get_data()\r\n        course_id = state_data['course_id']\r\n        block_id = await db.check_block_exists(course_id, selected_block)\r\n        await state.update_data(selected_block=selected_block)\r\n        if block_id:\r\n            year = datetime.now().year\r\n            month = datetime.now().month\r\n            await state.set_state(st.AddTask.choose_options)\r\n            await callback_query.message.edit_text('Выбери дату дедлайна',\r\n                                                   reply_markup=await kb.generate_calendar(year, month))\r\n        else:\r\n            await callback_query.message.edit_text(\r\n            f'Твой выбор: {selected_block}\\nТекущий блок на курсе: {state_data['current_block']}\\n\\nНачать новый блок и обновить всем пользователям жизни?', reply_markup=kb.confirm_new_block_keyboard)\r\n    new_text = f'Выбери блок\\n\\nТекущий выбор: {selected_block} блок'\r\n    if callback_query.message.text != new_text:\r\n        await callback_query.message.edit_text(text=f'Выбери блок\\n\\nТекущий выбор: {selected_block} блок',\r\n                                               reply_markup=await kb.to_change_block(selected_block))\r\n\r\n\r\n@router.callback_query(lambda c: c.data == 'cancel_update_block' or c.data == 'confirm_new_block')\r\nasync def confirm_new_block(callback_query: CallbackQuery, state: FSMContext):\r\n    action = callback_query.data\r\n    state_data = await state.get_data()\r\n    if action == 'cancel_update_block':\r\n        await callback_query.message.edit_text(\r\n            f'Выбери блок\\n\\nТекущий выбор: {state_data['current_block']} блок',\r\n            reply_markup=await kb.to_change_block(state_data['current_block']))\r\n    elif action == 'confirm_new_block':\r\n        year = datetime.now().year\r\n        month = datetime.now().month\r\n        await db.create_block(state_data['course_id'], state_data['selected_block'])\r\n        await state.set_state(st.AddTask.choose_options)\r\n        await callback_query.message.edit_text('Выбери дату дедлайна',\r\n                                               reply_markup=await kb.generate_calendar(year, month))\r\n\r\n\r\n@router.callback_query(lambda c: c.data.startswith('prev_month') or c.data.startswith('next_month'))\r\nasync def month(callback_query: CallbackQuery):\r\n    action, year, month = callback_query.data.split(\":\")\r\n    year, month = int(year), int(month)\r\n    if action == \"prev_month\":\r\n        if month == 1:\r\n            year -= 1\r\n            month = 12\r\n        else:\r\n            month -= 1\r\n    elif action == \"next_month\":\r\n        if month == 12:\r\n            year += 1\r\n            month = 1\r\n        else:\r\n            month += 1\r\n    new_markup = await kb.generate_calendar(year, month)\r\n    await callback_query.message.edit_reply_markup(reply_markup=new_markup)\r\n\r\n\r\n@router.callback_query(lambda c: c.data.startswith(\"select_day\"))\r\nasync def select_day(callback_query: CallbackQuery):\r\n    _, year, month, day = callback_query.data.split(\":\")\r\n    await callback_query.message.edit_text(\r\n        f\"Дата дедлайна: {day} {calendar.month_name[int(month)]} {year}\\nВыбери тип проверки:\",\r\n        reply_markup=await kb.choose_parameters_task(f'{day}-{month}-{year}'))\r\n\r\n\r\n@router.callback_query((lambda c: c.data.startswith('verif')))\r\nasync def choose_verification(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    _, verif, deadline_date = callback_query.data.split(':')\r\n    verif = 'Автоматическая проверка' if verif == 'auto' else 'Ручная проверка'\r\n    day, month, year = deadline_date.split('-')\r\n    await state.update_data(verification=verif, deadline=deadline_date)\r\n    await callback_query.message.edit_text(\r\n        f'''Дата дедлайна: {day} {calendar.month_name[int(month)]} {year}\\nТип проверки: {verif}\\nФайлы в заданиях:''',\r\n        reply_markup=kb.availability_files_task)\r\n\r\n\r\n@router.callback_query(lambda c: c.data.startswith('availability_files'))\r\nasync def process_availability_files(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    availability_files = callback_query.data.split(':')[-1]\r\n    await state.update_data(availability_files=True if availability_files == 'Да' else False)\r\n    current_text = callback_query.message.text\r\n    new_text = current_text + f' {availability_files}'\r\n    await callback_query.message.edit_text(text=new_text, reply_markup=kb.confirm_task)\r\n\r\n\r\n@router.callback_query(lambda c: c.data.startswith('finish_task'))\r\nasync def process_finish_task(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    action = callback_query.data.split(':')[-1]\r\n    if action == 'edit_task':\r\n        year = datetime.now().year\r\n        month = datetime.now().month\r\n        await callback_query.message.edit_text(f'Выбери дату дедлайна',\r\n                                               reply_markup=await kb.generate_calendar(year, month))\r\n    elif action == 'confirm_task':\r\n        await callback_query.message.edit_reply_markup(reply_markup=None)\r\n        await callback_query.message.answer('Отправь мне название урока')\r\n        await state.set_state(st.AddTask.get_task_title)\r\n\r\n\r\n@router.callback_query(F.data == 'send_exercise')\r\nasync def process_send_exercise(callback_query: CallbackQuery, state: FSMContext):\r\n    \"\"\"Создаем task. Проверяем, есть ли в задании автопроверка.\"\"\"\r\n    await callback_query.answer()\r\n    state_data = await state.get_data()\r\n    verif = state_data['verification']\r\n    task_id = await db.add_task(state_data['task_title'], state_data['block_id'], state_data['verification'],\r\n                                  state_data['video_id'], state_data['abstract_id'], state_data['availability_files'],\r\n                                  state_data['deadline'])\r\n    await state.update_data(task_id=task_id)\r\n    exercises = get_exersice()\r\n    if verif == 'Ручная проверка':\r\n        for exercise in exercises:\r\n            exercise_condition = exercise[0]\r\n            await db.add_exercise(task_id, exercise_condition)\r\n    elif verif == 'Автоматическая проверка':\r\n        for exercise in exercises:\r\n            exercise_condition = exercise[0]\r\n            exercise_answer = exercise[1]\r\n            await db.add_exercise(task_id, exercise_condition, exercise_answer)\r\n\r\n    current_date = datetime.now().strftime(\"%Y-%m-%d\")\r\n    if task_id == current_date:\r\n        pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/callbacks/create_task.py b/callbacks/create_task.py
--- a/callbacks/create_task.py	(revision b0591667e66263e7d38695590eb03be98f9ba183)
+++ b/callbacks/create_task.py	(date 1742544483685)
@@ -1,7 +1,8 @@
 from aiogram.fsm.context import FSMContext
-from aiogram.types import CallbackQuery, InputMediaVideo
+from aiogram.types import CallbackQuery
 from aiogram import Router, F
 from datetime import datetime
+from bot_instance import bot
 from google_table import get_exersice
 
 import calendar
@@ -62,9 +63,11 @@
             await state.set_state(st.AddTask.choose_options)
             await callback_query.message.edit_text('Выбери дату дедлайна',
                                                    reply_markup=await kb.generate_calendar(year, month))
+            await state.update_data(block_id=block_id)
         else:
             await callback_query.message.edit_text(
-            f'Твой выбор: {selected_block}\nТекущий блок на курсе: {state_data['current_block']}\n\nНачать новый блок и обновить всем пользователям жизни?', reply_markup=kb.confirm_new_block_keyboard)
+                f'Твой выбор: {selected_block}\nТекущий блок на курсе: {state_data['current_block']}\n\nНачать новый блок и обновить всем пользователям жизни?',
+                reply_markup=kb.confirm_new_block_keyboard)
     new_text = f'Выбери блок\n\nТекущий выбор: {selected_block} блок'
     if callback_query.message.text != new_text:
         await callback_query.message.edit_text(text=f'Выбери блок\n\nТекущий выбор: {selected_block} блок',
@@ -82,7 +85,9 @@
     elif action == 'confirm_new_block':
         year = datetime.now().year
         month = datetime.now().month
-        await db.create_block(state_data['course_id'], state_data['selected_block'])
+        block_id = await db.create_block(state_data['course_id'], state_data['selected_block'])
+        await db.update_lives(state_data['course_id'])
+        await state.update_data(block_id=block_id)
         await state.set_state(st.AddTask.choose_options)
         await callback_query.message.edit_text('Выбери дату дедлайна',
                                                reply_markup=await kb.generate_calendar(year, month))
@@ -113,7 +118,7 @@
     _, year, month, day = callback_query.data.split(":")
     await callback_query.message.edit_text(
         f"Дата дедлайна: {day} {calendar.month_name[int(month)]} {year}\nВыбери тип проверки:",
-        reply_markup=await kb.choose_parameters_task(f'{day}-{month}-{year}'))
+        reply_markup=await kb.choose_parameters_task(f'{year}-{month}-{day}'))
 
 
 @router.callback_query((lambda c: c.data.startswith('verif')))
@@ -160,9 +165,8 @@
     state_data = await state.get_data()
     verif = state_data['verification']
     task_id = await db.add_task(state_data['task_title'], state_data['block_id'], state_data['verification'],
-                                  state_data['video_id'], state_data['abstract_id'], state_data['availability_files'],
-                                  state_data['deadline'])
-    await state.update_data(task_id=task_id)
+                                state_data['video_id'], state_data['abstract_id'], state_data['availability_files'],
+                                state_data['deadline'])
     exercises = get_exersice()
     if verif == 'Ручная проверка':
         for exercise in exercises:
@@ -174,6 +178,9 @@
             exercise_answer = exercise[1]
             await db.add_exercise(task_id, exercise_condition, exercise_answer)
 
-    current_date = datetime.now().strftime("%Y-%m-%d")
-    if task_id == current_date:
-        pass
+    users_by_course = await db.get_users_by_course(state_data['course_id'])
+    for user_id in users_by_course:
+        await bot.send_message(chat_id=user_id,
+                               text=f'Привет! Только что был добавлен новый урок: {state_data['task_title']}\nЧтобы перейти к нему жми на кнопку!',
+                               reply_markup=await kb.start_the_task_from_the_reminder(state_data['course_id'],
+                                                                                task_id))
Index: deadline.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import asyncio\r\nfrom datetime import datetime\r\n\r\nfrom aiogram.fsm.context import FSMContext\r\nfrom apscheduler.schedulers.asyncio import AsyncIOScheduler\r\nfrom apscheduler.triggers.cron import CronTrigger\r\nfrom aiogram.types import Message\r\nfrom aiogram import Bot\r\n\r\nimport state as st\r\nimport database as db\r\nimport keyboard as kb\r\n\r\n\r\nasync def check_deadlines(timezone_id: int):\r\n    progress_users = await db.get_due_tasks_for_timezone(timezone_id, datetime.now().strftime(\"%Y-%m-%d\"))\r\n    if progress_users:\r\n        await db.update_deadlines_and_lives_bulk(progress_users, timezone_id)\r\n    print('Проверка была выполнена')\r\n\r\n\r\nasync def send_deadline_reminder(timezone_id, bot: Bot):\r\n    deadline_today = await db.get_today_deadline(user_id=None, timezone_id=timezone_id)\r\n    if deadline_today:\r\n        for deadline_data in deadline_today:\r\n\r\n            text_message = f\"Привет! Напоминаю, что сегодня в 0:00 дедлайн\\nНазвание урока: {deadline_data['task_title']}\"\r\n            await bot.send_message(deadline_data['user_id'], text_message,\r\n                                   reply_markup=await kb.start_the_task_from_the_reminder(deadline_data['course_id'],\r\n                                                                                          deadline_data['task_id']))\r\n    print('Напоминания разосланы')\r\n\r\nasync def update_jobs(scheduler, bot: Bot):\r\n    \"\"\"Функция для обновления расписания задач для всех часовых поясов.\"\"\"\r\n    timezones = await db.get_timezones()\r\n\r\n    print(\"Updating timezone jobs for:\", timezones)\r\n\r\n    for job in scheduler.get_jobs():\r\n        if job.id.startswith(\"task_\") or job.id.startswith(\"reminder_\"):\r\n            scheduler.remove_job(job.id)\r\n\r\n    for timezone_id in timezones:\r\n        tz_value = timezones[timezone_id]\r\n        scheduler.add_job(\r\n            check_deadlines,\r\n            trigger=CronTrigger(hour=11, minute=24, timezone=tz_value),\r\n            args=[timezone_id],\r\n            id=f\"task_{timezone_id}\"\r\n        )\r\n\r\n        scheduler.add_job(\r\n            send_deadline_reminder,\r\n            trigger=CronTrigger(hour=11, minute=23, timezone=tz_value),\r\n            args=[timezone_id, bot],\r\n            id=f\"reminder_{timezone_id}\"\r\n        )\r\n\r\n\r\n    print(\"Timezone jobs updated.\")\r\n\r\n\r\nasync def setup_monitoring(bot: Bot):\r\n    \"\"\"Основная функция, которая инициализирует планировщик и устанавливает глобальное обновление\"\"\"\r\n    scheduler = AsyncIOScheduler()\r\n    scheduler.start()\r\n    await update_jobs(scheduler, bot)\r\n\r\n    scheduler.add_job(\r\n        update_jobs,\r\n        trigger=CronTrigger(hour=11, minute=22, timezone=\"Europe/Moscow\"),\r\n        args=[scheduler, bot],\r\n        id=\"global_update\"\r\n    )\r\n\r\n    await asyncio.Event().wait()\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/deadline.py b/deadline.py
--- a/deadline.py	(revision b0591667e66263e7d38695590eb03be98f9ba183)
+++ b/deadline.py	(date 1742544483687)
@@ -44,14 +44,14 @@
         tz_value = timezones[timezone_id]
         scheduler.add_job(
             check_deadlines,
-            trigger=CronTrigger(hour=11, minute=24, timezone=tz_value),
+            trigger=CronTrigger(hour=0, minute=52, timezone=tz_value),
             args=[timezone_id],
             id=f"task_{timezone_id}"
         )
 
         scheduler.add_job(
             send_deadline_reminder,
-            trigger=CronTrigger(hour=11, minute=23, timezone=tz_value),
+            trigger=CronTrigger(hour=11, minute=50, timezone=tz_value),
             args=[timezone_id, bot],
             id=f"reminder_{timezone_id}"
         )
@@ -68,7 +68,7 @@
 
     scheduler.add_job(
         update_jobs,
-        trigger=CronTrigger(hour=11, minute=22, timezone="Europe/Moscow"),
+        trigger=CronTrigger(hour=0, minute=50, timezone="Europe/Moscow"),
         args=[scheduler, bot],
         id="global_update"
     )
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"Black\">\r\n    <option name=\"sdkName\" value=\"Python 3.13\" />\r\n  </component>\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.13 (EducatedPlatform)\" project-jdk-type=\"Python SDK\" />\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision b0591667e66263e7d38695590eb03be98f9ba183)
+++ b/.idea/misc.xml	(date 1742544483684)
@@ -3,5 +3,5 @@
   <component name="Black">
     <option name="sdkName" value="Python 3.13" />
   </component>
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.13 (EducatedPlatform)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.13" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
Index: .idea/EducatedPlatform.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\">\r\n      <excludeFolder url=\"file://$MODULE_DIR$/.venv\" />\r\n    </content>\r\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.13 (EducatedPlatform)\" jdkType=\"Python SDK\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/EducatedPlatform.iml b/.idea/EducatedPlatform.iml
--- a/.idea/EducatedPlatform.iml	(revision b0591667e66263e7d38695590eb03be98f9ba183)
+++ b/.idea/EducatedPlatform.iml	(date 1742544483683)
@@ -4,7 +4,7 @@
     <content url="file://$MODULE_DIR$">
       <excludeFolder url="file://$MODULE_DIR$/.venv" />
     </content>
-    <orderEntry type="jdk" jdkName="Python 3.13 (EducatedPlatform)" jdkType="Python SDK" />
+    <orderEntry type="jdk" jdkName="Python 3.13" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
Index: google_table.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from google.oauth2.service_account import Credentials\r\nimport gspread\r\n\r\n\r\ndef get_exersice():\r\n    try:\r\n        SERVICE_ACCOUNT_FILE = \"educatedplatform-3074c57a82e0.json\"\r\n        SCOPES = ['https://www.googleapis.com/auth/spreadsheets']\r\n\r\n        creds = Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=SCOPES)\r\n        gc = gspread.authorize(creds)\r\n\r\n        spreadsheet = gc.open_by_key(\"1dRVN0o5TVgZ7zfcPZOej8VCq508xeWfNhPLexWTINWE\")\r\n        worksheet = spreadsheet.sheet1\r\n\r\n        data = worksheet.get_all_values()\r\n        return data[1:]\r\n    except:\r\n        return 'Ошибка на стороне Google, попробуй еще раз'\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/google_table.py b/google_table.py
--- a/google_table.py	(revision b0591667e66263e7d38695590eb03be98f9ba183)
+++ b/google_table.py	(date 1742544483783)
@@ -4,7 +4,7 @@
 
 def get_exersice():
     try:
-        SERVICE_ACCOUNT_FILE = "educatedplatform-3074c57a82e0.json"
+        SERVICE_ACCOUNT_FILE = "educatedplatform-8219d1d704e8.json"
         SCOPES = ['https://www.googleapis.com/auth/spreadsheets']
 
         creds = Credentials.from_service_account_file(SERVICE_ACCOUNT_FILE, scopes=SCOPES)
@@ -15,5 +15,6 @@
 
         data = worksheet.get_all_values()
         return data[1:]
-    except:
+    except Exception as e:
+        print(e)
         return 'Ошибка на стороне Google, попробуй еще раз'
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"72d8baad-2a73-484a-8cc9-4ec8f1a86f25\" name=\"Changes\" comment=\"Добавлена история изменений жизней в базе данных\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/EducatedPlatform.iml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/EducatedPlatform.iml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/misc.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/misc.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/callbacks/create_task.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/callbacks/create_task.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/database.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/database.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/educated_platform.db\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/educated_platform.db\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/keyboard.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/keyboard.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/main.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/main.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;IlyaTimchuck&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/IlyaTimchuck/EducatedPlatform.git&quot;,\r\n    &quot;accountId&quot;: &quot;0e8c499a-e6aa-4e6f-90fb-34acffe04e66&quot;\r\n  }\r\n}</component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 1\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2s0xh0I6YShiUAj4jNGvrY50LiA\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Python.Unnamed.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.callbacks.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.database.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.google_table.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.main.executor&quot;: &quot;Run&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;master&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/EducatedPlatform&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.lookFeel&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\" selected=\"Python.main\">\r\n    <configuration name=\"Unnamed\" type=\"PythonConfigurationType\" factoryName=\"Python\" nameIsGenerated=\"true\">\r\n      <module name=\"EducatedPlatform\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"PythonConfigurationType\" factoryName=\"Python\">\r\n      <module name=\"EducatedProject\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"database\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"EducatedPlatform\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/database.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"google_table\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"EducatedPlatform\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/google_table.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"main\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"EducatedPlatform\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/main.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"Tox\" factoryName=\"Tox\">\r\n      <module name=\"EducatedProject\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"docs\" factoryName=\"Docutils task\">\r\n      <module name=\"EducatedProject\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"docutils_input_file\" value=\"\" />\r\n      <option name=\"docutils_output_file\" value=\"\" />\r\n      <option name=\"docutils_params\" value=\"\" />\r\n      <option name=\"docutils_task\" value=\"\" />\r\n      <option name=\"docutils_open_in_browser\" value=\"false\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"docs\" factoryName=\"Sphinx task\">\r\n      <module name=\"EducatedProject\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"docutils_input_file\" value=\"\" />\r\n      <option name=\"docutils_output_file\" value=\"\" />\r\n      <option name=\"docutils_params\" value=\"\" />\r\n      <option name=\"docutils_task\" value=\"\" />\r\n      <option name=\"docutils_open_in_browser\" value=\"false\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"tests\" factoryName=\"Autodetect\">\r\n      <module name=\"EducatedProject\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"_new_additionalArguments\" value=\"&quot;&quot;\" />\r\n      <option name=\"_new_target\" value=\"&quot;&quot;\" />\r\n      <option name=\"_new_targetType\" value=\"&quot;PATH&quot;\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"tests\" factoryName=\"Doctests\">\r\n      <module name=\"EducatedProject\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"\" />\r\n      <option name=\"CLASS_NAME\" value=\"\" />\r\n      <option name=\"METHOD_NAME\" value=\"\" />\r\n      <option name=\"FOLDER_NAME\" value=\"\" />\r\n      <option name=\"TEST_TYPE\" value=\"TEST_SCRIPT\" />\r\n      <option name=\"PATTERN\" value=\"\" />\r\n      <option name=\"USE_PATTERN\" value=\"false\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Python.Unnamed\" />\r\n      <item itemvalue=\"Python.database\" />\r\n      <item itemvalue=\"Python.google_table\" />\r\n      <item itemvalue=\"Python.main\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.main\" />\r\n        <item itemvalue=\"Python.google_table\" />\r\n        <item itemvalue=\"Python.database\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-python-sdk-fc1d50d2d915-aa17d162503b-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-243.24978.54\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"72d8baad-2a73-484a-8cc9-4ec8f1a86f25\" name=\"Changes\" comment=\"\" />\r\n      <created>1737606408278</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1737606408278</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Добавлена история изменений жизней в базе данных\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1741963449435</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1741963449435</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"2\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"Добавлена история изменений жизней в базе данных\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Добавлена история изменений жизней в базе данных\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision b0591667e66263e7d38695590eb03be98f9ba183)
+++ b/.idea/workspace.xml	(date 1742544520350)
@@ -4,15 +4,22 @@
     <option name="autoReloadType" value="SELECTIVE" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="72d8baad-2a73-484a-8cc9-4ec8f1a86f25" name="Changes" comment="Добавлена история изменений жизней в базе данных">
+    <list default="true" id="72d8baad-2a73-484a-8cc9-4ec8f1a86f25" name="Changes" comment="добавлена адаптация кнопки в главное меню под новую функцию">
+      <change afterPath="$PROJECT_DIR$/bot_instance.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/EducatedPlatform.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/EducatedPlatform.iml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/callbacks/create_task.py" beforeDir="false" afterPath="$PROJECT_DIR$/callbacks/create_task.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/callbacks/learning.py" beforeDir="false" afterPath="$PROJECT_DIR$/callbacks/learning.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/database.py" beforeDir="false" afterPath="$PROJECT_DIR$/database.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/deadline.py" beforeDir="false" afterPath="$PROJECT_DIR$/deadline.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/educated_platform.db" beforeDir="false" afterPath="$PROJECT_DIR$/educated_platform.db" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/google_table.py" beforeDir="false" afterPath="$PROJECT_DIR$/google_table.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/handlers/command_menu_admin.py" beforeDir="false" afterPath="$PROJECT_DIR$/handlers/command_menu_admin.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/handlers/command_menu_student.py" beforeDir="false" afterPath="$PROJECT_DIR$/handlers/command_menu_student.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/keyboard.py" beforeDir="false" afterPath="$PROJECT_DIR$/keyboard.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/main.py" beforeDir="false" afterPath="$PROJECT_DIR$/main.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/registration.py" beforeDir="false" afterPath="$PROJECT_DIR$/registration.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -37,8 +44,8 @@
 }</component>
   <component name="GithubPullRequestsUISettings">{
   &quot;selectedUrlAndAccountId&quot;: {
-    &quot;url&quot;: &quot;https://github.com/IlyaTimchuck/EducatedPlatform.git&quot;,
-    &quot;accountId&quot;: &quot;0e8c499a-e6aa-4e6f-90fb-34acffe04e66&quot;
+    &quot;url&quot;: &quot;https://github.com/IlyaTimchuck/EducatedPlatform&quot;,
+    &quot;accountId&quot;: &quot;0673eef9-6c6a-4377-9177-4560af06ab4a&quot;
   }
 }</component>
   <component name="ProjectColorInfo">{
@@ -58,7 +65,6 @@
     &quot;Python.google_table.executor&quot;: &quot;Run&quot;,
     &quot;Python.main.executor&quot;: &quot;Run&quot;,
     &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
-    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,
     &quot;git-widget-placeholder&quot;: &quot;master&quot;,
     &quot;last_opened_file_path&quot;: &quot;C:/EducatedPlatform&quot;,
     &quot;settings.editor.selected.configurable&quot;: &quot;preferences.lookFeel&quot;
@@ -272,7 +278,7 @@
   <component name="SharedIndexes">
     <attachedChunks>
       <set>
-        <option value="bundled-python-sdk-fc1d50d2d915-aa17d162503b-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-243.24978.54" />
+        <option value="bundled-python-sdk-6a3326d57233-c546a90a8094-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-242.24807.21" />
       </set>
     </attachedChunks>
   </component>
@@ -285,15 +291,6 @@
       <option name="presentableId" value="Default" />
       <updated>1737606408278</updated>
     </task>
-    <task id="LOCAL-00001" summary="Добавлена история изменений жизней в базе данных">
-      <option name="closed" value="true" />
-      <created>1741963449435</created>
-      <option name="number" value="00001" />
-      <option name="presentableId" value="LOCAL-00001" />
-      <option name="project" value="LOCAL" />
-      <updated>1741963449435</updated>
-    </task>
-    <option name="localTasksCounter" value="2" />
     <servers />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
@@ -307,8 +304,4 @@
       </map>
     </option>
   </component>
-  <component name="VcsManagerConfiguration">
-    <MESSAGE value="Добавлена история изменений жизней в базе данных" />
-    <option name="LAST_COMMIT_MESSAGE" value="Добавлена история изменений жизней в базе данных" />
-  </component>
 </project>
\ No newline at end of file
Index: callbacks/learning.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from aiogram.fsm.context import FSMContext\r\nfrom aiogram.types import CallbackQuery, InputMediaVideo, InlineKeyboardMarkup\r\nfrom aiogram import Router, F\r\nfrom datetime import datetime\r\n\r\nimport state as st\r\nimport database as db\r\nimport keyboard as kb\r\n\r\nrouter = Router()\r\n\r\n@router.callback_query(F.data == 'block_list')\r\nasync def open_blocks_list(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    user_id = callback_query.from_user.id\r\n    user_data = await db.get_data_user(user_id)\r\n    await callback_query.message.edit_text('\uD83C\uDF93 Доступные блоки занятий:',\r\n                                           reply_markup=await kb.mapping_block_list(user_data['course_id']))\r\n\r\n\r\n@router.callback_query(lambda c: c.data.startswith('open_block'))\r\nasync def open_tasks_list(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    action, course_id, block_id = callback_query.data.split(':')\r\n    user_id = callback_query.from_user.id\r\n    if action == 'open_block_from_homework':\r\n        state_data = await state.get_data()\r\n        abstract = state_data.get('message_abstract_id', False)\r\n        if abstract:\r\n            await callback_query.message.bot.delete_message(chat_id=callback_query.message.chat.id, message_id=abstract)\r\n        await state.clear()\r\n        await state.set_state(st.MappingExercise.mapping_task)\r\n        await state.update_data(course_id=course_id)\r\n        await callback_query.message.delete()\r\n        await callback_query.message.answer('Список занятий:',\r\n                                            reply_markup=await kb.mapping_list_tasks(user_id, int(course_id),\r\n                                                                                     int(block_id)))\r\n    else:\r\n        await state.update_data(course_id=course_id)\r\n        await callback_query.message.edit_text('Список занятий:',\r\n                                               reply_markup=await kb.mapping_list_tasks(user_id, int(course_id),\r\n                                                                                        int(block_id)))\r\n\r\n\r\n@router.callback_query(lambda c: c.data.startswith('open_task'))\r\nasync def open_task(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    await state.set_state(st.MappingExercise.mapping_task)\r\n    action, course_id, task_id = callback_query.data.split(':')\r\n    task_id = int(task_id)\r\n    task_data = await db.get_data_task(task_id)\r\n    text_message = f'Название урока: {task_data['task_title']}\\nДедлайн: {task_data['deadline']}'\r\n    session = await db.get_last_session(callback_query.from_user.id, task_id)\r\n    progress_user = await db.get_progress_user(task_id, session['session_id']) if session else\\\r\n        await db.get_progress_user(task_id)\r\n    state_data = await state.get_data()\r\n    if progress_user:\r\n        await state.update_data(results=progress_user)\r\n        right_answers = len(\r\n            [exercise_num for exercise_num in progress_user if\r\n             progress_user[exercise_num]['status_input_answer'] == '✅'])\r\n        quantity_exercise = len(await db.get_list_exercises(task_data['task_id']))\r\n        quotient = int((right_answers / quantity_exercise) * 100)\r\n        text_message += f\"\\nДомашняя работа: {quotient}% {'✅' if quotient >= 90 else '❌'}\"\r\n        await state.update_data(quantity_right_answers=right_answers, quantity_exercise=quantity_exercise)\r\n\r\n    sent_message = await callback_query.message.edit_media(\r\n        media=InputMediaVideo(\r\n            media=task_data['video_id'],\r\n            caption=text_message),\r\n        reply_markup=await kb.mapping_task(course_id, task_data['block_id'], state_data.get('abstract_retrieved', False))\r\n    )\r\n    await state.update_data(task_data=task_data, task_message_id=sent_message.message_id, course_id=course_id)\r\n\r\n@router.callback_query(F.data == 'open_homework')\r\nasync def mapping_homework(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    await callback_query.message.edit_reply_markup(reply_markup=None)\r\n    state_data = await state.get_data()\r\n    homework = await db.get_list_exercises(state_data['task_data']['task_id'])\r\n    await state.set_state(st.MappingExercise.solving_homework)\r\n    quantity_exercise = len(homework)\r\n    current_exercise = 1\r\n    if 'results' in state_data:\r\n        text_message = f'{homework[current_exercise][0]}\\nТвой ответ: {' '.join(map(str, state_data['results'].get(current_exercise, {}).values()))}'\r\n    else:\r\n        text_message = homework[current_exercise][0]\r\n    sent_message = await callback_query.message.answer(text=text_message,\r\n                                                       reply_markup= await kb.mapping_homework(quantity_exercise,\r\n                                                                                        current_exercise))\r\n    await state.update_data(quantity_exercise=quantity_exercise, homework=homework, current_exercise=current_exercise,\r\n                            current_message_id=sent_message.message_id,\r\n                            session_start=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"))\r\n\r\n\r\n@router.callback_query(F.data == 'open_list_exercises')\r\nasync def opening_list_exercises(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    state_data = await state.get_data()\r\n    await callback_query.message.edit_text(text='Выбери задание',\r\n                                           reply_markup=await kb.mapping_list_exercises(state_data,\r\n                                                                                        'results' in state_data))\r\n\r\n\r\n@router.callback_query(F.data == 'get_abstract')\r\nasync def send_abstract(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    task_data = (await state.get_data())['task_data']\r\n    sent_message = await callback_query.message.answer_document(document=task_data['abstract_id'])\r\n    await state.update_data(message_abstract_id=sent_message.message_id, abstract_retrieved=True)\r\n    current_keyboard = callback_query.message.reply_markup.inline_keyboard\r\n    new_keyboard = [\r\n        [button for button in row if button.callback_data != 'get_abstract']\r\n        for row in current_keyboard\r\n    ]\r\n    await callback_query.message.edit_reply_markup(\r\n        reply_markup=InlineKeyboardMarkup(inline_keyboard=new_keyboard)\r\n    )\r\n\r\n@router.callback_query(lambda c: c.data.startswith('next_exercise') or c.data.startswith('prev_exercise')\r\n                                 or c.data.startswith('open_exercise'))\r\nasync def mapping_exercise(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    current_exercise = int(callback_query.data.split(':')[-1])\r\n    state_data = await state.get_data()\r\n    quantity_exercise = state_data['quantity_exercise']\r\n    homework = state_data['homework']\r\n    answers = state_data.get('results', {})\r\n\r\n    if current_exercise in answers:\r\n        answer_data = answers[current_exercise]\r\n        user_answer = answer_data.get('input_answer', '')\r\n        status = answer_data.get('status_input_answer', '')\r\n        text_message = f\"{homework[current_exercise][0]}\\nТвой ответ: {user_answer} {status}\"\r\n    else:\r\n        text_message = homework[current_exercise][0]\r\n\r\n    current_message = await callback_query.message.edit_text(\r\n        text=text_message,\r\n        reply_markup=await kb.mapping_homework(quantity_exercise, current_exercise)\r\n    )\r\n\r\n    await state.update_data(\r\n        current_exercise=current_exercise,\r\n        current_text=current_message.text,\r\n        current_message_id=current_message.message_id)\r\n\r\n\r\n@router.callback_query(F.data == 'complete_homework')\r\nasync def completing_homework(callback_query: CallbackQuery, state: FSMContext):\r\n    state_data = await state.get_data()\r\n    task_data = state_data['task_data']\r\n    session_end = datetime.now().strftime(\"%Y-%m-%d\")\r\n    quotient = int((state_data['quantity_right_answers'] / state_data['quantity_exercise']) * 100)\r\n    is_completed = quotient >= 90\r\n    await db.add_progress_user(callback_query.from_user.id, task_data['task_id'], state_data['homework'],\r\n                               state_data.get('results', {}), state_data['session_start'], session_end, is_completed)\r\n    await callback_query.answer(\r\n        'Домашняя работа была принята' if is_completed else 'Порог не был пройден. Нужно минимум 90%',\r\n        show_alert=False if is_completed else True)\r\n    await callback_query.message.delete()\r\n    await callback_query.bot.edit_message_media(\r\n        chat_id=callback_query.message.chat.id,\r\n        message_id=state_data['task_message_id'],\r\n        media=InputMediaVideo(\r\n            media=task_data['video_id'],\r\n            caption=f'Название урока: {task_data['task_title']}\\nДедлайн: {task_data['deadline']}\\nДомашняя работа: {quotient}% {'✅' if quotient >= 90 else '❌'}'),\r\n        reply_markup=await kb.mapping_task(state_data['course_id'], task_data['block_id'], state_data.get('abstract_retrieved', False))\r\n    )\r\n\r\n\r\n@router.callback_query(F.data == \"ignore\")\r\nasync def ignore_callback(callback_query: CallbackQuery):\r\n    await callback_query.answer()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/callbacks/learning.py b/callbacks/learning.py
--- a/callbacks/learning.py	(revision b0591667e66263e7d38695590eb03be98f9ba183)
+++ b/callbacks/learning.py	(date 1742544483686)
@@ -9,8 +9,9 @@
 
 router = Router()
 
+
 @router.callback_query(F.data == 'block_list')
-async def open_blocks_list(callback_query: CallbackQuery, state: FSMContext):
+async def open_blocks_list(callback_query: CallbackQuery):
     await callback_query.answer()
     user_id = callback_query.from_user.id
     user_data = await db.get_data_user(user_id)
@@ -49,9 +50,11 @@
     action, course_id, task_id = callback_query.data.split(':')
     task_id = int(task_id)
     task_data = await db.get_data_task(task_id)
-    text_message = f'Название урока: {task_data['task_title']}\nДедлайн: {task_data['deadline']}'
+    date_obj = datetime.strptime(task_data['deadline'], '%Y-%m-%d')
+    deadline = date_obj.strftime('%d-%m-%Y')
+    text_message = f'Название урока: {task_data['task_title']}\nДедлайн: {deadline}'
     session = await db.get_last_session(callback_query.from_user.id, task_id)
-    progress_user = await db.get_progress_user(task_id, session['session_id']) if session else\
+    progress_user = await db.get_progress_user(task_id, session['session_id']) if session else \
         await db.get_progress_user(task_id)
     state_data = await state.get_data()
     if progress_user:
@@ -68,10 +71,12 @@
         media=InputMediaVideo(
             media=task_data['video_id'],
             caption=text_message),
-        reply_markup=await kb.mapping_task(course_id, task_data['block_id'], state_data.get('abstract_retrieved', False))
+        reply_markup=await kb.mapping_task(course_id, task_data['block_id'],
+                                           state_data.get('abstract_retrieved', False))
     )
     await state.update_data(task_data=task_data, task_message_id=sent_message.message_id, course_id=course_id)
 
+
 @router.callback_query(F.data == 'open_homework')
 async def mapping_homework(callback_query: CallbackQuery, state: FSMContext):
     await callback_query.answer()
@@ -79,6 +84,7 @@
     state_data = await state.get_data()
     homework = await db.get_list_exercises(state_data['task_data']['task_id'])
     await state.set_state(st.MappingExercise.solving_homework)
+
     quantity_exercise = len(homework)
     current_exercise = 1
     if 'results' in state_data:
@@ -86,8 +92,8 @@
     else:
         text_message = homework[current_exercise][0]
     sent_message = await callback_query.message.answer(text=text_message,
-                                                       reply_markup= await kb.mapping_homework(quantity_exercise,
-                                                                                        current_exercise))
+                                                       reply_markup=await kb.mapping_homework(quantity_exercise,
+                                                                                              current_exercise))
     await state.update_data(quantity_exercise=quantity_exercise, homework=homework, current_exercise=current_exercise,
                             current_message_id=sent_message.message_id,
                             session_start=datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
@@ -117,6 +123,7 @@
         reply_markup=InlineKeyboardMarkup(inline_keyboard=new_keyboard)
     )
 
+
 @router.callback_query(lambda c: c.data.startswith('next_exercise') or c.data.startswith('prev_exercise')
                                  or c.data.startswith('open_exercise'))
 async def mapping_exercise(callback_query: CallbackQuery, state: FSMContext):
@@ -151,7 +158,7 @@
     state_data = await state.get_data()
     task_data = state_data['task_data']
     session_end = datetime.now().strftime("%Y-%m-%d")
-    quotient = int((state_data['quantity_right_answers'] / state_data['quantity_exercise']) * 100)
+    quotient = int((state_data.get('quantity_right_answers', 0) / state_data['quantity_exercise']) * 100)
     is_completed = quotient >= 90
     await db.add_progress_user(callback_query.from_user.id, task_data['task_id'], state_data['homework'],
                                state_data.get('results', {}), state_data['session_start'], session_end, is_completed)
@@ -165,10 +172,11 @@
         media=InputMediaVideo(
             media=task_data['video_id'],
             caption=f'Название урока: {task_data['task_title']}\nДедлайн: {task_data['deadline']}\nДомашняя работа: {quotient}% {'✅' if quotient >= 90 else '❌'}'),
-        reply_markup=await kb.mapping_task(state_data['course_id'], task_data['block_id'], state_data.get('abstract_retrieved', False))
+        reply_markup=await kb.mapping_task(state_data['course_id'], task_data['block_id'],
+                                           state_data.get('abstract_retrieved', False))
     )
 
 
 @router.callback_query(F.data == "ignore")
 async def ignore_callback(callback_query: CallbackQuery):
-    await callback_query.answer()
\ No newline at end of file
+    await callback_query.answer()
