Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from asyncio import run, create_task, CancelledError\r\nfrom handlers.__init__ import setup_routers\r\nfrom callbacks.__init__ import setup_routers_callbacks\r\nfrom bot_instance import bot, dp\r\nfrom deadline import setup_monitoring\r\nfrom google_table import setup_google_polling_loop, google_client\r\nimport database as db\r\nimport asyncio\r\n\r\n\r\nasync def main() -> None:\r\n    setup_routers(dp)\r\n    setup_routers_callbacks(dp)\r\n    await db.create_db()\r\n    await db.create_course('Тестовый')\r\n    course_id = await db.get_course_id('Тестовый')\r\n    await db.add_users(['itimchuck'], course_id)\r\n    await db.add_users(['try_user'], course_id)\r\n    monitor_task = create_task(setup_monitoring())\r\n    google_polling_task = create_task(setup_google_polling_loop(google_client))\r\n    task_id = await db.add_task('Задание 16', course_id, True,\r\n                                'BAACAgIAAxkBAAIFk2ecdMIb9MARHD1FCDBfDykIyVA8AAIQYAAChk_gSJ5yxpryw_xrNgQ',\r\n                                'BQACAgIAAxkBAAID4GeW8STy6kbcasFhPk_ZNds1Q5u1AAKwdAACV7G4SHyUzFl8D_k0NgQ',\r\n                                'https://drive.google.com/drive/folders/1IlsIZjIGWKO1ZfeRLxScOu0W58DFwaF0?usp=drive_link',\r\n                                '2025-03-31')\r\n    await db.add_exercise(task_id,\r\n                          'Узлы с IP-адресами 157.220.185.237 и 157.220.184.230 принадлежат одной сети. Какое наименьшее количество IP-адресов, в двоичной записи которых ровно 15 единиц, может содержаться в этой сети?',\r\n                          '12')\r\n    await db.add_exercise(task_id,\r\n                          'Сеть, в которой содержится узел с IP-адресом 192.214.A.184, задана маской сети 255.255.255.224, где A - некоторое допустимое для записи IP-адреса число. Определите минимальное значение A, для которого для всех IP-адресов этой сети в двоичной записи IP-адреса суммарное количество единиц будет больше 15.',\r\n                          '43')\r\n    await db.add_exercise(task_id,\r\n                          '''В снежном королевстве существовала особая сеть, которая имела свой уникальный IP-адрес и маску.\r\nОднажды, Снежная Королева решила провести эксперимент, чтобы выяснить, сколько IP-адресов в её королевстве соответствуют определённому правилу. Она знала, что сеть ее королевства задается следующими данными:\r\nIP-адрес сети: 192.168.248.176\r\nСетевая маска: 255.255.255.240\r\nНеобходимо узнать, сколько в этой сети IP-адресов, для которых количество единиц и нулей в двоичной записи IP-адреса одинаково.''',\r\n                          '43')\r\n\r\n    try:\r\n        await dp.start_polling(bot)\r\n    finally:\r\n        monitor_task.cancel()\r\n        try:\r\n            await monitor_task\r\n        except CancelledError:\r\n            print(\"Monitoring task cancelled\")\r\n        await bot.session.close()\r\n\r\n\r\nif __name__ == '__main__':\r\n    run(main())\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 96802b670d37253d439b2386d5f719e7303aea1c)
+++ b/main.py	(date 1744963627378)
@@ -1,23 +1,24 @@
 from asyncio import run, create_task, CancelledError
 from handlers.__init__ import setup_routers
 from callbacks.__init__ import setup_routers_callbacks
+from command_menu_admin import router as command_menu_admin_router
 from bot_instance import bot, dp
 from deadline import setup_monitoring
 from google_table import setup_google_polling_loop, google_client
 import database as db
-import asyncio
 
 
 async def main() -> None:
     setup_routers(dp)
     setup_routers_callbacks(dp)
+    dp.include_router(command_menu_admin_router)
     await db.create_db()
     await db.create_course('Тестовый')
     course_id = await db.get_course_id('Тестовый')
     await db.add_users(['itimchuck'], course_id)
     await db.add_users(['try_user'], course_id)
     monitor_task = create_task(setup_monitoring())
-    google_polling_task = create_task(setup_google_polling_loop(google_client))
+    create_task(setup_google_polling_loop(google_client))
     task_id = await db.add_task('Задание 16', course_id, True,
                                 'BAACAgIAAxkBAAIFk2ecdMIb9MARHD1FCDBfDykIyVA8AAIQYAAChk_gSJ5yxpryw_xrNgQ',
                                 'BQACAgIAAxkBAAID4GeW8STy6kbcasFhPk_ZNds1Q5u1AAKwdAACV7G4SHyUzFl8D_k0NgQ',
Index: keyboard.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, Message\r\n\r\nimport database as db\r\nfrom aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder\r\nimport calendar\r\n\r\n\r\nasync def mapping_block_list(course_id: int):\r\n    data = await db.get_blocks(course_id)\r\n    builder = InlineKeyboardBuilder()\r\n    for block in data:\r\n        builder.row(InlineKeyboardButton(text=f'{block} блок', callback_data=f'open_block:{course_id}:{data[block]}'))\r\n    builder.row(*[InlineKeyboardButton(text='Назад', callback_data='back_student')])\r\n    return builder.as_markup()\r\n\r\n\r\nasync def mapping_list_tasks(user_id: int, course_id: int, block_id: int) -> InlineKeyboardMarkup:\r\n    builder = InlineKeyboardBuilder()\r\n    tasks = await db.get_list_tasks(block_id)\r\n    for task_title in tasks:\r\n        task_id = tasks[task_title]\r\n        task_status = await db.mapping_task_status(user_id, task_id)\r\n        builder.row(\r\n            *[InlineKeyboardButton(text=f'{task_title}{task_status}',\r\n                                   callback_data=f'open_task:{course_id}:{task_id}:0')])\r\n    return builder.as_markup()\r\n\r\n\r\nasync def mapping_homework(quantity_exercise: int, current_exercise: int, file_work: bool) -> InlineKeyboardMarkup:\r\n    builder = InlineKeyboardBuilder()\r\n    if current_exercise == 1:\r\n        builder.add(\r\n            InlineKeyboardButton(text=f'{current_exercise}/{quantity_exercise}', callback_data='open_list_exercises'),\r\n            InlineKeyboardButton(text='\\u2192', callback_data=f'next_exercise:{current_exercise + 1}'))\r\n        builder.adjust(2)\r\n    elif current_exercise == quantity_exercise:\r\n        builder.add(InlineKeyboardButton(text=\"\\u2190\", callback_data=f'prev_exercise:{current_exercise - 1}'),\r\n                    InlineKeyboardButton(text=f'{current_exercise}/{quantity_exercise}',\r\n                                         callback_data='open_list_exercises'))\r\n        builder.adjust(2)\r\n    else:\r\n        builder.add(\r\n            InlineKeyboardButton(text=\"\\u2190\", callback_data=f'prev_exercise:{current_exercise - 1}'),\r\n            InlineKeyboardButton(text=f'{current_exercise}/{quantity_exercise}', callback_data='open_list_exercises'),\r\n            InlineKeyboardButton(text='\\u2192', callback_data=f'next_exercise:{current_exercise + 1}'))\r\n        builder.adjust(3)\r\n    if file_work:\r\n        builder.row(\r\n            *[InlineKeyboardButton(text='Сохранить ответы и перейти к отправке файла', callback_data='get_file_work')])\r\n    else:\r\n        builder.row(*[InlineKeyboardButton(text='Завершить выполнение работы', callback_data='complete_homework')])\r\n    return builder.as_markup()\r\n\r\n\r\nasync def mapping_task(course_id, block_id, abstract_retrieved: bool = False) -> InlineKeyboardMarkup:\r\n    keyboard_buttons = [\r\n        [InlineKeyboardButton(text='Домашняя работа', callback_data='open_homework')]\r\n    ]\r\n    if not abstract_retrieved:\r\n        keyboard_buttons.append(\r\n            [InlineKeyboardButton(text='Конспект урока', callback_data='get_abstract')]\r\n        )\r\n    keyboard_buttons.append([\r\n        InlineKeyboardButton(text='Назад', callback_data=f'open_block_from_homework:{course_id}:{block_id}'),\r\n        InlineKeyboardButton(text='В главное меню', callback_data='back_student')\r\n    ])\r\n    return InlineKeyboardMarkup(inline_keyboard=keyboard_buttons)\r\n\r\n\r\nasync def mapping_list_exercises(state_data: dict, decides: bool) -> InlineKeyboardMarkup:\r\n    builder = InlineKeyboardBuilder()\r\n    task_id = state_data['task_data']['task_id']\r\n    homework = state_data['homework']\r\n    if decides:\r\n        results = state_data.get('results', {})\r\n        for exercise_number in homework:\r\n            result_status = results.get(exercise_number, {}).get('status_input_answer', '⌛')\r\n            builder.add(InlineKeyboardButton(\r\n                text=f'{exercise_number} задание {result_status}',\r\n                callback_data=f'open_exercise:{exercise_number}'\r\n            ))\r\n    else:\r\n        progress_solving = await db.get_progress_user(task_id)\r\n        for exercise_number in homework:\r\n            if exercise_number in progress_solving:\r\n                status = '⌛' if progress_solving[exercise_number]['input_answer'] is None else \\\r\n                    progress_solving[exercise_number]['exercise_status']\r\n            else:\r\n                status = '⌛'  # Или любой другой значок, если данных нет\r\n\r\n            builder.add(InlineKeyboardButton(\r\n                text=f'{exercise_number} задание {status}',\r\n                callback_data=f'open_exercise:{exercise_number}'\r\n            ))\r\n\r\n    builder.adjust(1)\r\n    return builder.as_markup()\r\n\r\n\r\nasync def choose_parameters_task(deadline) -> InlineKeyboardMarkup:\r\n    keyboard = InlineKeyboardMarkup(\r\n        inline_keyboard=[[InlineKeyboardButton(text='Нет', callback_data=f'verif:0:{deadline}'),\r\n                          InlineKeyboardButton(text='Да', callback_data=f'verif:1:{deadline}')]\r\n                         ])\r\n    return keyboard\r\n\r\n\r\nasync def generate_calendar(year: int, month: int) -> InlineKeyboardMarkup:\r\n    builder = InlineKeyboardBuilder()\r\n    builder.row(\r\n        InlineKeyboardButton(text=\"\\u2190\", callback_data=f\"prev_month:{year}:{month}\"),\r\n        InlineKeyboardButton(text=f\"{year}, {calendar.month_name[month]}\", callback_data=\"ignore\"),\r\n        InlineKeyboardButton(text=\"\\u2192\", callback_data=f\"next_month:{year}:{month}\")\r\n    )\r\n    day_names = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс']\r\n    builder.row(*[InlineKeyboardButton(text=day, callback_data='ignore') for day in day_names])\r\n    month_calendar = calendar.monthcalendar(year, month)\r\n    for week in month_calendar:\r\n        builder.row(*[\r\n            InlineKeyboardButton(text=str(day) if day != 0 else ' ',\r\n                                 callback_data=f'select_day:{year}:{month}:{day}')\r\n            for day in week])\r\n    return builder.as_markup()\r\n\r\n\r\nasync def to_change_block(current_block):\r\n    change_block_buttons = InlineKeyboardMarkup(inline_keyboard=[\r\n        [InlineKeyboardButton(text='Предыдущий блок', callback_data=f'reduce_block:{current_block}'),\r\n         InlineKeyboardButton(text='Следующий блок', callback_data=f'increase_block:{current_block}')],\r\n        [InlineKeyboardButton(text='Подтвердить выбор', callback_data=f'confirm_block:{current_block}')],\r\n        [InlineKeyboardButton(text='Назад', callback_data='back_admin')]\r\n    ])\r\n    return change_block_buttons\r\n\r\n\r\nasync def choose_course_inline():\r\n    \"\"\"Используется для добавления задания\"\"\"\r\n    builder = InlineKeyboardBuilder()\r\n    courses = await db.get_list_courses()\r\n    for course in courses:\r\n        builder.add(\r\n            InlineKeyboardButton(text=course['course_title'], callback_data=f\"choose_course:{course['course_title']}\"))\r\n\r\n    return builder.as_markup(resize_keyboard=True, one_time_keyboard=True)\r\n\r\n\r\nasync def choose_course_reply():\r\n    \"\"\"Используется для добавления списка пользователей\"\"\"\r\n    builder = ReplyKeyboardBuilder()\r\n    courses = await db.get_list_courses()\r\n    builder.add(KeyboardButton(text='Создать новый'))\r\n    for course in courses:\r\n        builder.add(KeyboardButton(text=course['course_title']))\r\n    builder.adjust(2)\r\n    return builder.as_markup(resize_keyboard=True, one_time_keyboard=True)\r\n\r\n\r\nasync def send_command_menu(user_id: int):\r\n    user_data = await db.get_data_user(user_id)\r\n    if user_data['role'] == 'student':\r\n        last_task = await db.get_last_task(user_id)\r\n        callback_data_last_task = f'open_task:{last_task['course_id']}:{last_task['task_id']}:0' if last_task else 'ignore'\r\n        command_menu = InlineKeyboardMarkup(inline_keyboard=[\r\n            [InlineKeyboardButton(text='Список занятий', callback_data='block_list')],\r\n            [InlineKeyboardButton(text='Открыть последнее занятие', callback_data=callback_data_last_task)],\r\n            [InlineKeyboardButton(text='Посмотреть историю жизней', callback_data='list_lives')],\r\n        ])\r\n        lives = user_data['lives']\r\n        deadline_today = await db.get_today_deadline_for_keyboard(user_id)\r\n        text_message = f'Текущее количество жизней: {lives * '❤\uFE0F'}\\n'\r\n        if deadline_today:\r\n            text_message += f'Дедлайны сегодня: {', '.join(task['task_title'] for task in deadline_today)}'\r\n        else:\r\n            text_message += 'Дедлайны сегодня: -'\r\n        return text_message, command_menu\r\n    elif user_data['role'] == 'admin':\r\n        command_menu = InlineKeyboardMarkup(inline_keyboard=[\r\n            [InlineKeyboardButton(text='Добавить урок', callback_data='add_lesson')],\r\n            [InlineKeyboardButton(text='Добвить пользователей', callback_data='add_users')]\r\n        ])\r\n        text_message = 'Распознал тебя как админа'\r\n        return text_message, command_menu\r\n\r\n\r\nasync def start_the_task_from_the_reminder(course_id: int, task_id: int) -> InlineKeyboardMarkup:\r\n    button = InlineKeyboardMarkup(inline_keyboard=[\r\n        [InlineKeyboardButton(text='Приступить к выполнению задания',\r\n                              callback_data=f'open_task:{course_id}:{task_id}:1')]\r\n    ])\r\n    return button\r\n\r\n\r\nback_button_student = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Назад', callback_data='back_student')]\r\n])\r\n\r\nback_button_admin = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Назад', callback_data='back_admin')]\r\n])\r\n\r\nsend_homework_keyboard = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Редактировать введённые данные', callback_data='change_homework')],\r\n    [InlineKeyboardButton(text='Отправить домашнюю работу', callback_data='send_homework')]\r\n])\r\n\r\navailability_files_task = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Нет', callback_data='availability_files:Нет'),\r\n     InlineKeyboardButton(text='Да', callback_data='availability_files:Да')]\r\n])\r\n\r\nconfirm_task = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Редактировать', callback_data='finish_task:edit_task'),\r\n     InlineKeyboardButton(text='Подтвердить', callback_data='finish_task:confirm_task')]\r\n])\r\n\r\nsend_exercise = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Отправить данные из таблицы в базу данных', callback_data='send_exercise')]\r\n])\r\n\r\nlocation_button = ReplyKeyboardMarkup(\r\n    keyboard=[\r\n        [KeyboardButton(text=\"\uD83D\uDCCD Отправить геолокацию\", request_location=True)]\r\n    ],\r\n    resize_keyboard=True,\r\n    one_time_keyboard=True\r\n)\r\n\r\nconfirm_new_block_keyboard = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Отменить', callback_data='cancel_update_block'),\r\n     InlineKeyboardButton(text='Подтвердить', callback_data='confirm_new_block')]\r\n])\r\n\r\nback_to_homework = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Вернуться к домашней работе', callback_data='open_homework')]\r\n])\r\n\r\nconfirm_completing_work_file = InlineKeyboardMarkup(inline_keyboard=[\r\n    [InlineKeyboardButton(text='Вернуться назад', callback_data='open_homework'),\r\n     InlineKeyboardButton(text='Завершить', callback_data='complete_homework')]\r\n])\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/keyboard.py b/keyboard.py
--- a/keyboard.py	(revision 96802b670d37253d439b2386d5f719e7303aea1c)
+++ b/keyboard.py	(date 1744963627378)
@@ -190,6 +190,13 @@
     return button
 
 
+async def confirm_deleting_user(user_id: int) -> InlineKeyboardMarkup:
+    keyboard = InlineKeyboardMarkup(inline_keyboard=[
+        [InlineKeyboardButton(text='Отменить', callback_data=f'cancel_deleting:{user_id}'),
+         InlineKeyboardButton(text='Подтвердить', callback_data=f'confirm_deleting:{user_id}')]
+    ])
+    return keyboard
+
 back_button_student = InlineKeyboardMarkup(inline_keyboard=[
     [InlineKeyboardButton(text='Назад', callback_data='back_student')]
 ])
Index: google_table.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from google.oauth2.service_account import Credentials\r\nimport gspread_asyncio\r\nfrom googleapiclient.discovery import build\r\nfrom bot_instance import bot\r\nimport asyncio\r\nimport database as db\r\n\r\n\r\nclass GoogleSheetsClient:\r\n    def __init__(self, creds_file, spreadsheet_id) -> None:\r\n        self._agcm = None\r\n        self._spreadsheet = None\r\n        self._drive_service = None\r\n        self._last_modified_time = None\r\n        self._creds_file = creds_file\r\n        self._spreadsheet_id = spreadsheet_id\r\n        self._max_retries = 2\r\n\r\n    async def _reinitialize(self) -> None:\r\n        SCOPES = ['https://www.googleapis.com/auth/spreadsheets']\r\n        for attempt in range(1, self._max_retries + 1):\r\n            try:\r\n                creds = Credentials.from_service_account_file(self._creds_file, scopes=SCOPES)\r\n                self._agcm = gspread_asyncio.AsyncioGspreadClientManager(lambda: creds)\r\n                ags = await self._agcm.authorize()\r\n                self._spreadsheet = await ags.open_by_key(self._spreadsheet_id)\r\n                return\r\n            except Exception as e:\r\n                await bot.send_message(chat_id=795508218,\r\n                                       text=f'{attempt} попытка авторизации google_sheets не была выполнена. Ошибка: {e}')\r\n                print(f'Ошибка авторизации {e}')\r\n                await asyncio.sleep(1)\r\n        self._spreadsheet = None\r\n\r\n    async def _ensure_authorized(self, function_name) -> None:\r\n        if self._spreadsheet is None:\r\n            await self._reinitialize()\r\n        if self._spreadsheet is None:\r\n            await bot.send_message(chat_id=795508218,\r\n                                   text=f'При выполнении функции {function_name} произошла ошибка авторизации')\r\n\r\n    async def _init_drive_service(self):\r\n        scopes = ['https://www.googleapis.com/auth/drive']\r\n\r\n        def build_service():\r\n            creds = Credentials.from_service_account_file(self._creds_file, scopes=scopes)\r\n            return build('drive', 'v3', credentials=creds)\r\n\r\n        drive_service = await asyncio.to_thread(build_service)\r\n        return drive_service\r\n\r\n    async def get_exersice(self) -> list | str:\r\n        await self._ensure_authorized('get_exercise')\r\n        worksheet = await self._spreadsheet.get_worksheet(0)\r\n        data = await worksheet.get_all_values()\r\n        return data[1:]\r\n\r\n    async def add_user_in_table(self, real_name: str, telegram_username: str, course_title: str, user_id: int,\r\n                                timezone: str,\r\n                                date_of_joining: str, role: str, lives: int) -> None:\r\n        await self._ensure_authorized('add_user_in_table')\r\n        worksheet = await self._spreadsheet.worksheet('users')\r\n        row_data = [real_name, telegram_username, course_title, user_id, timezone,\r\n                    date_of_joining, role, f'{lives}❤\uFE0F']\r\n        await worksheet.append_row(row_data)\r\n\r\n    async def check_for_updates(self):\r\n        await self._ensure_authorized('check_for_updates')\r\n        drive_service = await self._init_drive_service()\r\n\r\n        file_metadata = await asyncio.to_thread(\r\n            lambda: drive_service.files().get(\r\n                fileId=self._spreadsheet_id,\r\n                fields='modifiedTime'\r\n            ).execute()\r\n        )\r\n        modified_time = file_metadata['modifiedTime']\r\n        print(f\"Время последнего изменения: {file_metadata.get('modifiedTime')}\")\r\n        if self._last_modified_time is None:\r\n            self._last_modified_time = modified_time\r\n            return True\r\n\r\n        if modified_time != self._last_modified_time:\r\n            self._last_modified_time = modified_time\r\n            return True\r\n\r\n        return False\r\n\r\n\r\ngoogle_client = GoogleSheetsClient(creds_file='educatedplatform-8219d1d704e8.json',\r\n                                   spreadsheet_id='1dRVN0o5TVgZ7zfcPZOej8VCq508xeWfNhPLexWTINWE')\r\n\r\n\r\nasync def setup_google_polling_loop(google_sheets_client: GoogleSheetsClient):\r\n    while True:\r\n        try:\r\n            has_updates = await google_sheets_client.check_for_updates()\r\n            if has_updates:\r\n                print('Произошло обновление таблицы')\r\n                worksheet = await google_sheets_client._spreadsheet.worksheet('users')\r\n                data = await worksheet.get_all_values()\r\n                print(data)\r\n            await asyncio.sleep(5)\r\n        except Exception as e:\r\n            print(e)\r\n            await bot.send_message(chat_id=795508218,\r\n                                   text=f'В мониторинге google_polling_loop произошла ошибка: {e}')\r\n            await asyncio.sleep(1)\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/google_table.py b/google_table.py
--- a/google_table.py	(revision 96802b670d37253d439b2386d5f719e7303aea1c)
+++ b/google_table.py	(date 1744963627378)
@@ -4,16 +4,17 @@
 from bot_instance import bot
 import asyncio
 import database as db
+import keyboard as kb
 
 
 class GoogleSheetsClient:
     def __init__(self, creds_file, spreadsheet_id) -> None:
         self._agcm = None
-        self._spreadsheet = None
+        self.spreadsheet = None
         self._drive_service = None
         self._last_modified_time = None
         self._creds_file = creds_file
-        self._spreadsheet_id = spreadsheet_id
+        self.spreadsheet_id = spreadsheet_id
         self._max_retries = 2
 
     async def _reinitialize(self) -> None:
@@ -23,19 +24,19 @@
                 creds = Credentials.from_service_account_file(self._creds_file, scopes=SCOPES)
                 self._agcm = gspread_asyncio.AsyncioGspreadClientManager(lambda: creds)
                 ags = await self._agcm.authorize()
-                self._spreadsheet = await ags.open_by_key(self._spreadsheet_id)
+                self.spreadsheet = await ags.open_by_key(self.spreadsheet_id)
                 return
             except Exception as e:
                 await bot.send_message(chat_id=795508218,
                                        text=f'{attempt} попытка авторизации google_sheets не была выполнена. Ошибка: {e}')
                 print(f'Ошибка авторизации {e}')
                 await asyncio.sleep(1)
-        self._spreadsheet = None
+        self.spreadsheet = None
 
     async def _ensure_authorized(self, function_name) -> None:
-        if self._spreadsheet is None:
+        if self.spreadsheet is None:
             await self._reinitialize()
-        if self._spreadsheet is None:
+        if self.spreadsheet is None:
             await bot.send_message(chat_id=795508218,
                                    text=f'При выполнении функции {function_name} произошла ошибка авторизации')
 
@@ -51,7 +52,7 @@
 
     async def get_exersice(self) -> list | str:
         await self._ensure_authorized('get_exercise')
-        worksheet = await self._spreadsheet.get_worksheet(0)
+        worksheet = await self.spreadsheet.get_worksheet(0)
         data = await worksheet.get_all_values()
         return data[1:]
 
@@ -59,9 +60,10 @@
                                 timezone: str,
                                 date_of_joining: str, role: str, lives: int) -> None:
         await self._ensure_authorized('add_user_in_table')
-        worksheet = await self._spreadsheet.worksheet('users')
-        row_data = [real_name, telegram_username, course_title, user_id, timezone,
-                    date_of_joining, role, f'{lives}❤️']
+        worksheet = await self.spreadsheet.worksheet('users')
+        status = 'active'
+        row_data = [real_name, telegram_username, course_title, str(user_id), timezone,
+                    date_of_joining, role, status, f'{lives}❤️', '-']
         await worksheet.append_row(row_data)
 
     async def check_for_updates(self):
@@ -70,7 +72,7 @@
 
         file_metadata = await asyncio.to_thread(
             lambda: drive_service.files().get(
-                fileId=self._spreadsheet_id,
+                fileId=self.spreadsheet_id,
                 fields='modifiedTime'
             ).execute()
         )
@@ -87,25 +89,37 @@
         return False
 
 
-google_client = GoogleSheetsClient(creds_file='educatedplatform-8219d1d704e8.json',
+google_client = GoogleSheetsClient(creds_file='educatedplatform-a40aded26c1c.json',
                                    spreadsheet_id='1dRVN0o5TVgZ7zfcPZOej8VCq508xeWfNhPLexWTINWE')
 
 
 async def setup_google_polling_loop(google_sheets_client: GoogleSheetsClient):
+    await google_sheets_client.check_for_updates()
     while True:
         try:
             has_updates = await google_sheets_client.check_for_updates()
             if has_updates:
                 print('Произошло обновление таблицы')
-                worksheet = await google_sheets_client._spreadsheet.worksheet('users')
-                data = await worksheet.get_all_values()
-                print(data)
-            await asyncio.sleep(5)
+                worksheet = await google_sheets_client.spreadsheet.worksheet('users')
+                data = (await worksheet.get_all_values())[1:]
+                for num_row, row_data in enumerate(data, 2):
+                    print(row_data)
+                    if row_data[-3] == 'deleted':
+                        username = row_data[1]
+                        user_id = row_data[3]
+                        await worksheet.delete_rows(num_row)
+                        await bot.send_message(chat_id=795508218,
+                                               text=f'Вы действительно хотите удалить пользователя @{username} и все связанные с ним данные?',
+                                               reply_markup=await kb.confirm_deleting_user(user_id))
+                    elif row_data[-1] != '-':
+                        user_id = int(row_data[3])
+                        new_lives_count = int(row_data[8][0])
+                        await db.update_lives_for_user(user_id, new_lives_count)
+                        await worksheet.update_cell(row=num_row, col=10, value='-')
+
+            await asyncio.sleep(60)
         except Exception as e:
             print(e)
             await bot.send_message(chat_id=795508218,
                                    text=f'В мониторинге google_polling_loop произошла ошибка: {e}')
-            await asyncio.sleep(1)
-
-
-
+            await asyncio.sleep(60)
Index: registration.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from datetime import datetime\r\n\r\nfrom aiogram.types import Message\r\nfrom aiogram.fsm.context import FSMContext\r\nfrom aiogram import Router\r\nfrom timezonefinder import TimezoneFinder\r\nfrom geopy.geocoders import Nominatim\r\nimport state as st\r\nimport database as db\r\nimport keyboard as kb\r\nimport utils\r\nfrom google_table import google_client\r\n\r\nrouter = Router()\r\n\r\n\r\n@router.message(st.Registration.get_name_user)\r\nasync def getting_name_user(message: Message, state: FSMContext):\r\n    name_user_split = message.text.split()\r\n    reg_msg_for_deletion = await state.get_value('reg_msg_for_deletion', [])\r\n    if len(name_user_split) == 2 and len(name_user_split[0]) >= 2 and len(name_user_split[1]) >= 2:\r\n        name_user = f'{name_user_split[0][0].upper()}{name_user_split[0][1:].lower()} {name_user_split[1][0].upper()}{name_user_split[1][1:].lower()}'\r\n        sent_message = await message.answer(\r\n            'Теперь отправь мне свою локацию или название ближайшего большого города. Это нужно для корректного отображения дедлайнов',\r\n            reply_markup=kb.location_button)\r\n        reg_msg_for_deletion += [sent_message.message_id]\r\n        reg_msg_for_deletion += [message.message_id]\r\n        await state.update_data(real_name=name_user, reg_msg_for_deletion=reg_msg_for_deletion)\r\n        await state.set_state(st.Registration.get_location_user)\r\n    else:\r\n        sent_message = await message.answer('Кажется, ты отправил некорректные имя/фамилию. Попробуй еще раз')\r\n        reg_msg_for_deletion += [sent_message.message_id]\r\n        reg_msg_for_deletion += [message.message_id]\r\n        await state.update_data(reg_msg_for_deletion=reg_msg_for_deletion)\r\n        await state.set_state(st.Registration.get_name_user)\r\n\r\n\r\n@router.message(st.Registration.get_location_user)\r\nasync def registration_user(message: Message, state: FSMContext):\r\n    state_data = await state.get_data()\r\n    reg_msg_for_deletion = state_data['reg_msg_for_deletion']\r\n    reg_msg_for_deletion += [message.message_id]\r\n    latitude, longitude = None, None\r\n    # Если пользователь отправил геолокацию, используем её\r\n    if message.location:\r\n        latitude = message.location.latitude\r\n        longitude = message.location.longitude\r\n    # Если отправлен текст, считаем, что это название города и проводим геокодинг\r\n    elif message.text:\r\n        geolocator = Nominatim(user_agent=\"timezone_app\")\r\n        location = geolocator.geocode(message.text)\r\n        if location is None:\r\n            sent_message_1 = await message.answer(\r\n                \"Город не найден. Пожалуйста, проверьте название и попробуйте еще раз.\")\r\n            reg_msg_for_deletion += [sent_message_1.message_id]\r\n            return\r\n        latitude = location.latitude\r\n        longitude = location.longitude\r\n    else:\r\n        await message.answer(\"Пожалуйста, отправь название города или свою геолокацию.\")\r\n        return\r\n\r\n    # Определяем часовой пояс по координатам\r\n    tf = TimezoneFinder()\r\n    timezone_name = tf.timezone_at(lat=latitude, lng=longitude)\r\n    if timezone_name is None:\r\n        sent_message_2 = await message.answer(\r\n            \"Не удалось определить часовой пояс по указанным данным. Попробуйте снова.\")\r\n        reg_msg_for_deletion += [sent_message_2.message_id]\r\n        return\r\n    role = 'student'  # if message.from_user.id != 795508218 else 'admin'\r\n    real_name_user = state_data['real_name']\r\n    # Регистрируем пользователя в базе данных\r\n    course_user = await db.registration_user(real_name_user, message.from_user.username, message.from_user.id,\r\n                                             timezone_name, role)\r\n    if course_user:\r\n        date_of_joining = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\r\n        await google_client.add_user_in_table(real_name_user, message.from_user.username, course_user[1],\r\n                                              message.from_user.id,\r\n                                              timezone_name, date_of_joining, role, 3)\r\n        text_message, keyboard = await kb.send_command_menu(message.from_user.id)\r\n        text_message = f'Твой часовой пояс распознан как {timezone_name}\\n' + text_message\r\n        await utils.del_messages(message.from_user.id, reg_msg_for_deletion)\r\n        message_menu = await message.answer(text_message, reply_markup=keyboard)\r\n        state_data['command_menu_id'] = message_menu.message_id\r\n        state_data.pop('reg_msg_for_deletion')\r\n        if role == 'student':\r\n            await state.set_state(st.MappingExercise.mapping_command_menu)\r\n            await state.set_data(state_data)\r\n    else:\r\n        sent_message_3 = await message.answer(\r\n            'Ты не был добавлен админом на курс. Тебе нужно обратиться к админу :(')\r\n        reg_msg_for_deletion += [sent_message_3.message_id]\r\n        await state.set_state(st.Registration.get_location_user)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/registration.py b/registration.py
--- a/registration.py	(revision 96802b670d37253d439b2386d5f719e7303aea1c)
+++ b/registration.py	(date 1744963627384)
@@ -75,13 +75,13 @@
                                              timezone_name, role)
     if course_user:
         date_of_joining = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
-        await google_client.add_user_in_table(real_name_user, message.from_user.username, course_user[1],
-                                              message.from_user.id,
-                                              timezone_name, date_of_joining, role, 3)
         text_message, keyboard = await kb.send_command_menu(message.from_user.id)
         text_message = f'Твой часовой пояс распознан как {timezone_name}\n' + text_message
         await utils.del_messages(message.from_user.id, reg_msg_for_deletion)
         message_menu = await message.answer(text_message, reply_markup=keyboard)
+        await google_client.add_user_in_table(real_name_user, message.from_user.username, course_user[1],
+                                              message.from_user.id,
+                                              timezone_name, date_of_joining, role, 3)
         state_data['command_menu_id'] = message_menu.message_id
         state_data.pop('reg_msg_for_deletion')
         if role == 'student':
Index: database.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from zoneinfo import ZoneInfo\r\nfrom datetime import datetime, timedelta\r\nimport aiosqlite\r\nfrom collections import defaultdict\r\n\r\nimport pytz\r\n\r\n\r\ndef current_datetime():\r\n    return datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\r\n\r\n\r\nasync def create_db() -> None:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        await con.execute(\"DROP TABLE IF EXISTS unregistered\")\r\n        await con.execute(\"DROP TABLE IF EXISTS users\")\r\n        await con.execute(\"DROP TABLE IF EXISTS courses\")\r\n        await con.execute(\"DROP TABLE IF EXISTS blocks\")\r\n        await con.execute(\"DROP TABLE IF EXISTS tasks\")\r\n        await con.execute(\"DROP TABLE IF EXISTS exercises\")\r\n        await con.execute(\"DROP TABLE IF EXISTS learning_progress\")\r\n        await con.execute(\"DROP TABLE IF EXISTS sessions\")\r\n        await con.execute(\"DROP TABLE IF EXISTS changed_deadlines\")\r\n        await con.execute(\"DROP TABLE IF EXISTS unique_timezones\")\r\n        await con.execute(\"DROP TABLE IF EXISTS history_of_lives\")\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS unregistered (\r\n            telegram_username TEXT,\r\n            course_id INTEGER)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS users (\r\n            real_name TEXT,\r\n            telegram_username TEXT,\r\n            user_id INTEGER,\r\n            course_id INTEGER,\r\n            timezone_id INTEGER,\r\n            date_of_joining TEXT,\r\n            lives INTEGER,\r\n            role TEXT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS courses(\r\n            course_title TEXT,\r\n            course_id INTEGER PRIMARY KEY AUTOINCREMENT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS blocks (\r\n            course_id INTEGER,\r\n            block_number INTEGER, \r\n            block_id INTEGER PRIMARY KEY AUTOINCREMENT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS tasks (\r\n            task_title TEXT,\r\n            task_id INTEGER PRIMARY KEY AUTOINCREMENT, \r\n            block_id INTEGER,\r\n            file_work BOOL,\r\n            video_id TEXT,\r\n            abstract_id TEXT,\r\n            link_files TEXT,\r\n            deadline TEXT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS exercises (\r\n             task_id INTEGER,\r\n             exercise_id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n             exercise_condition TEXT,\r\n             exercise_answer TEXT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS learning_progress (\r\n             user_id INTEGER, \r\n             exercise_id INTEGER, \r\n             input_answer TEXT, \r\n             right_answer BOOL, \r\n             session_id INTEGER)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS sessions (\r\n            session_id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n            user_id INTEGER,\r\n            task_id INTEGER,\r\n            is_completed BOOL,\r\n            session_start TEXT,\r\n            session_end TEXT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS changed_deadlines (\r\n                user_id INTEGER,\r\n                task_id INTEGER,\r\n                deadline TEXT,\r\n                PRIMARY KEY (user_id, task_id))''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS unique_timezones (\r\n            timezone TEXT,\r\n            timezone_id INTEGER PRIMARY KEY AUTOINCREMENT)''')\r\n\r\n        await con.execute('''CREATE TABLE IF NOT EXISTS history_of_lives (\r\n            user_id INTEGER,\r\n            task_id INTEGER,\r\n            lives_after_action INTEGER,\r\n            action TEXT)''')  # action: +1, +3, -1...\r\n\r\n        # await con.execute('''CREATE TABLE IF NOT EXISTS  requires_verification (\r\n        #     user_id INTEGER,\r\n        #     task_id INTEGER,\r\n        #     file_id TEXT,\r\n        #     verified BOOL DEFAULT 0)''')\r\n        await con.commit()\r\n\r\n\r\n# Registration\r\nasync def create_course(course_title) -> None:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        await con.execute('INSERT INTO courses (course_title) VALUES(?)', (course_title,))\r\n        await con.commit()\r\n        course_id = await get_course_id(course_title)\r\n        await con.execute('INSERT INTO blocks (course_id, block_number) VALUES(?, ?)',\r\n                          (course_id, 1))\r\n        await con.commit()\r\n\r\n\r\nasync def add_users(telegram_usernames: list, course_id: int) -> None:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        for username in telegram_usernames:\r\n            await con.execute('INSERT INTO unregistered VALUES(?, ?)', (username, course_id))\r\n        await con.commit()\r\n\r\n\r\nasync def user_is_unregistered(telegram_username: str) -> bool:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        result = await con.execute('''SELECT EXISTS \r\n        (SELECT 1 FROM unregistered WHERE telegram_username = ?)''', (telegram_username,))\r\n        row = await result.fetchone()\r\n        return bool(row[0])\r\n\r\n\r\nasync def registration_user(real_name: str, telegram_username: str, user_id: int, timezone: str, role: str) -> list:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        tz_record = await (await con.execute(\r\n            \"SELECT timezone_id FROM unique_timezones WHERE timezone = ?\",\r\n            (timezone,))).fetchone()\r\n\r\n        if not tz_record:\r\n            await con.execute(\r\n                \"INSERT INTO unique_timezones (timezone) VALUES (?)\",\r\n                (timezone,)\r\n            )\r\n            tz_record = await (await con.execute(\"SELECT last_insert_rowid()\")).fetchone()\r\n\r\n        timezone_id = tz_record[0]\r\n        date_of_joining = current_datetime()\r\n        lives = 3\r\n        cursor = await con.execute('''SELECT c.course_id, c.course_title\r\n                    FROM unregistered un\r\n                    JOIN courses c ON c.course_id = un.course_id\r\n                    WHERE un.telegram_username = ?''', (telegram_username,))\r\n        course_data = (await cursor.fetchall())[0]\r\n        if course_data:\r\n            await con.execute('INSERT INTO users VALUES (?, ?, ?, ?, ?, ?, ?, ?)',\r\n                              (real_name, telegram_username, user_id, course_data[0], timezone_id, date_of_joining, lives, role))\r\n            await con.execute('INSERT INTO history_of_lives VALUES(?, ?, ?, ?)', (user_id, None, None, '+3'))\r\n            await con.execute('DELETE FROM unregistered WHERE telegram_username = ?', (telegram_username,))\r\n            await con.commit()\r\n        return course_data\r\n\r\n\r\n# Other function\r\nasync def get_users_by_course(course_id: int) -> list:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute('SELECT user_id FROM users WHERE course_id=? AND role = ?', (course_id, 'student'))\r\n        result = await cursor.fetchall()\r\n        return [x[0] for x in result] if result else []\r\n\r\n\r\nasync def get_data_user(user_id: int) -> dict:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        async with con.cursor() as cursor:\r\n            await cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))\r\n            row = await cursor.fetchone()\r\n            if row:\r\n                return dict(row)\r\n            else:\r\n                return {}\r\n\r\n\r\nasync def get_list_courses() -> list:\r\n    \"\"\"Возвращает список всех названий курсов из базы данных.\"\"\"\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = 'SELECT course_title, course_id FROM courses'\r\n        async with con.execute(query) as cursor:\r\n            rows = await cursor.fetchall()\r\n            return [dict(row) for row in rows] if rows else []\r\n\r\n\r\nasync def get_blocks(course_id: int, current: bool = False) -> dict | int:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute('SELECT block_number, block_id FROM blocks WHERE course_id = ?', (course_id,))\r\n        rows = await cursor.fetchall()\r\n        if current:\r\n            if rows:\r\n                return max(int(x[0]) for x in rows)\r\n            else:\r\n                return 0\r\n        return {int(x[0]): int(x[1]) for x in rows}\r\n\r\n\r\nasync def get_course_id(course_title: str) -> int:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute('SELECT course_id FROM courses WHERE course_title=?', (course_title,))\r\n        course_id = await cursor.fetchone()\r\n        return course_id[0]\r\n\r\n\r\nasync def check_block_exists(course_id: int, block_number: int) -> int:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        async with con.execute(\r\n                '''SELECT b.block_id\r\n                    FROM blocks b\r\n                    WHERE b.course_id = ? AND b.block_number = ?\r\n                ''',\r\n                (course_id, block_number)\r\n        ) as cursor:\r\n            result = await cursor.fetchall()\r\n            return int(result[0][0]) if result else None\r\n\r\n\r\nasync def create_block(course_id: int, block_number: int) -> int:\r\n    \"\"\"Создает новый блок и возвращает его ID\"\"\"\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute(\r\n            'INSERT INTO blocks (course_id, block_number) VALUES (?, ?)',\r\n            (course_id, block_number)\r\n        )\r\n        await con.commit()\r\n        return cursor.lastrowid\r\n\r\n\r\nasync def add_task(task_title: str, block_id: int, file_work: bool, video_id: str, abstract_id: str,\r\n                   link_files: str | None, deadline: str) -> int:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        await con.execute(\r\n            '''INSERT INTO tasks (task_title, block_id, file_work, video_id, abstract_id, link_files, deadline)\r\n                                                                        VALUES(?, ?, ?, ?, ?, ?, ?)''',\r\n            (task_title, block_id, file_work, video_id, abstract_id, link_files, deadline))\r\n        await con.commit()\r\n        task_id = await con.execute('SELECT task_id FROM tasks WHERE video_id = ?', (video_id,))\r\n        return (await task_id.fetchone())[0]\r\n\r\n\r\nasync def add_exercise(task_id: int, exercise_condition: str, exercise_answer=None) -> None:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        if exercise_answer is None:\r\n            await con.execute(\r\n                'INSERT INTO exercises (task_id, exercise_condition) VALUES(?, ?)',\r\n                (task_id, exercise_condition))\r\n        else:\r\n            await con.execute(\r\n                'INSERT INTO exercises (task_id, exercise_condition, exercise_answer) VALUES(?, ?, ?)',\r\n                (task_id, exercise_condition, exercise_answer))\r\n        await con.commit()\r\n\r\n\r\n# mapping lesson\r\nasync def get_list_exercises(task_id: int) -> dict:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute(\r\n            'SELECT exercise_condition, exercise_answer, exercise_id FROM exercises WHERE task_id = ?',\r\n            (task_id,))\r\n        result = await cursor.fetchall()\r\n        return {num: (row[0], row[1], row[2]) for num, row in enumerate(result, 1)}\r\n\r\n\r\nasync def get_list_tasks(block_id: int) -> dict:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        async with con.cursor() as cursor:\r\n            cursor = await con.execute('SELECT task_title, task_id FROM tasks WHERE block_id=?',\r\n                                       (block_id,))\r\n            row = await cursor.fetchall()\r\n            if row:\r\n                return dict(row)\r\n            else:\r\n                return {}\r\n\r\n\r\nasync def mapping_task_status(user_id: int, task_id: int) -> str:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = '''\r\n            SELECT \r\n                COUNT(e.exercise_id) AS total_exercises,\r\n                SUM(lp.right_answer) AS completed_exercises,\r\n                COALESCE(cd.deadline, t.deadline) AS deadline\r\n            FROM tasks t\r\n            JOIN exercises e \r\n                ON t.task_id = e.task_id\r\n            LEFT JOIN changed_deadlines cd \r\n                ON cd.task_id = t.task_id\r\n               AND cd.user_id = ?\r\n            LEFT JOIN learning_progress lp\r\n                ON lp.exercise_id = e.exercise_id\r\n               AND lp.user_id = ?\r\n            WHERE t.task_id = ?\r\n        '''\r\n        async with con.execute(query, (user_id, user_id, task_id)) as cursor:\r\n            row = await cursor.fetchone()\r\n\r\n            if not row or row['total_exercises'] == 0:\r\n                return '❌'\r\n\r\n            total_exercises = row['total_exercises']\r\n            completed_exercises = row['completed_exercises'] or 0\r\n            deadline_str = row['deadline']\r\n\r\n            # Парсим дедлайн с учетом того, что он может содержать только дату\r\n            deadline = None\r\n            if deadline_str:\r\n                try:\r\n                    # Если строка содержит только дату (YYYY-MM-DD)\r\n                    if len(deadline_str) == 10:\r\n                        deadline = datetime.strptime(deadline_str, '%Y-%m-%d')\r\n                    else:\r\n                        deadline = datetime.strptime(deadline_str, '%Y-%m-%d %H:%M:%S')\r\n                except ValueError:\r\n                    # Если формат не соответствует ни одному из ожидаемых вариантов,\r\n                    # можно залогировать ошибку или задать deadline = None\r\n                    deadline = None\r\n\r\n            # Если дедлайн задан и прошёл, и не все упражнения выполнены до дедлайна – возвращаем ❌\r\n            if deadline and datetime.now() > deadline and completed_exercises < total_exercises:\r\n                return '❌'\r\n\r\n            # Если все упражнения выполнены – возвращаем ✅\r\n            if completed_exercises == total_exercises:\r\n                return '✅'\r\n\r\n            # Иначе возвращаем статус \"в процессе\" – ⏳\r\n            return '⏳'\r\n\r\n\r\nasync def get_data_task(task_id: int):\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = '''SELECT * FROM tasks WHERE task_id = ?'''\r\n        async with con.execute(query, (task_id,)) as cursor:\r\n            task_data = await cursor.fetchone()\r\n            return dict(task_data)\r\n\r\n\r\n# Recording response(answer) user\r\nasync def get_progress_user(task_id: int, session_id: int = None) -> dict:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n\r\n        query = \"\"\"\r\n        SELECT\r\n            e.exercise_id,\r\n            lp.input_answer,\r\n            lp.right_answer\r\n        FROM\r\n            learning_progress AS lp\r\n        JOIN\r\n            exercises AS e ON lp.exercise_id = e.exercise_id\r\n        WHERE\r\n            e.task_id = ?\r\n        \"\"\"\r\n\r\n        params = (task_id,)\r\n        if session_id is not None:\r\n            query += \" AND lp.session_id = ?\"\r\n            params += (session_id,)\r\n\r\n        async with con.execute(query, params) as cursor:\r\n            result = await cursor.fetchall()\r\n            if result:\r\n                return {row['exercise_id']: {'input_answer': row['input_answer'],\r\n                                             'status_input_answer': '✅' if row['right_answer'] else '❌'}\r\n                        for row in result}\r\n            else:\r\n                return {}\r\n\r\n\r\nasync def add_progress_user(user_id: int, task_id: int, homework: dict, results: dict, session_start: str,\r\n                            session_end: str, is_completed: bool = False) -> None:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute(\r\n            'INSERT INTO sessions (user_id, task_id, is_completed, session_start, session_end) VALUES (?, ?, ?, ?, ?)',\r\n            (user_id, task_id, is_completed, session_start, session_end)\r\n        )\r\n        session_id = cursor.lastrowid\r\n\r\n        for exercise_num in homework:\r\n            _, right_answer, exercise_id = homework[exercise_num]\r\n            input_answer = results.get(exercise_num, {}).get('input_answer', None)\r\n            if input_answer is not None:\r\n                is_correct = (str(input_answer).strip() == str(right_answer).strip())\r\n                await con.execute(\r\n                    'INSERT INTO learning_progress VALUES(?, ?, ?, ?, ?)',\r\n                    (user_id, exercise_id, input_answer, is_correct, session_id)\r\n                )\r\n        await con.commit()\r\n\r\n\r\nasync def get_last_session(user_id: int, task_id: int) -> dict:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = '''\r\n            SELECT *\r\n            FROM sessions\r\n            WHERE user_id = ? AND task_id = ?\r\n            ORDER BY session_id DESC\r\n            LIMIT 1\r\n        '''\r\n        async with con.execute(query, (user_id, task_id)) as cursor:\r\n            row = await cursor.fetchone()\r\n            return dict(row) if row else {}\r\n\r\n\r\nasync def get_timezones() -> dict:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = 'SELECT * FROM unique_timezones'\r\n        async with await con.execute(query) as cursor:\r\n            rows = await cursor.fetchall()\r\n            return {row[\"timezone_id\"]: row[\"timezone\"] for row in rows} if rows else {}\r\n\r\n\r\nasync def get_due_tasks_for_timezone(timezone_id: int, current_date: str) -> list:\r\n    \"\"\"\r\n    Возвращает список строк, где каждая строка содержит:\r\n      - user_id: идентификатор пользователя\r\n      - task_id: идентификатор задания\r\n      - actual_deadline: дедлайн, учитывающий changed_deadlines\r\n      - is_completed: статус завершения сессии (может быть None, если сессии нет)\r\n    Для заданий, дедлайн которых равен current_date,\r\n    и пользователей с заданным timezone_id.\r\n    Возвращает только тех пользователей, у которых нет сессий с is_completed = 1.\r\n    \"\"\"\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = \"\"\"SELECT\r\n                u.user_id,\r\n                t.task_id,\r\n                u.lives\r\n            FROM tasks t\r\n            JOIN blocks b ON b.block_id = t.block_id\r\n            JOIN users u ON u.course_id = b.course_id\r\n            LEFT JOIN changed_deadlines cd ON cd.task_id = t.task_id AND cd.user_id = u.user_id\r\n            LEFT JOIN sessions s ON s.task_id = t.task_id AND s.user_id = u.user_id\r\n            WHERE u.timezone_id = ?\r\n              AND COALESCE(cd.deadline, t.deadline) = ?\r\n            GROUP BY u.user_id, t.task_id\r\n            HAVING MAX(s.is_completed) IS NULL OR MAX(s.is_completed) = 0\r\n                    \"\"\"\r\n\r\n        async with con.execute(query, (timezone_id, current_date)) as cursor:\r\n            rows = await cursor.fetchall()\r\n            return [dict(row) for row in rows] if rows else []\r\n\r\n\r\nasync def update_deadlines_and_lives_bulk(updates: list, timezone_id: int) -> None:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        # Получаем значение timezone из unique_timezones\r\n        async with con.execute(\"SELECT timezone FROM unique_timezones WHERE timezone_id = ?\", (timezone_id,)) as cur:\r\n            row = await cur.fetchone()\r\n            if not row:\r\n                raise ValueError(f\"Timezone with id {timezone_id} not found\")\r\n            tz_value = str(row[0])\r\n\r\n        # Вычисляем новый дедлайн как завтрашнюю дату с учетом timezone\r\n        new_deadline = (datetime.now(tz=ZoneInfo(tz_value)) + timedelta(days=1)).strftime(\"%Y-%m-%d %H:%M:%S\")\r\n\r\n        await con.execute(\"BEGIN TRANSACTION\")\r\n        try:\r\n            # Группируем уникальные пары (user_id, task_id)\r\n            unique_pairs = {(u[\"user_id\"], u[\"task_id\"]) for u in updates}\r\n\r\n            # Обновляем дедлайны в changed_deadlines с использованием UPSERT\r\n            await con.executemany(\r\n                \"\"\"INSERT INTO changed_deadlines (user_id, task_id, deadline)\r\n                   VALUES (?, ?, ?)\r\n                   ON CONFLICT(user_id, task_id) \r\n                   DO UPDATE SET deadline = excluded.deadline\"\"\",\r\n                [(user_id, task_id, new_deadline) for user_id, task_id in unique_pairs]\r\n            )\r\n\r\n            # Считаем количество списаний для каждого пользователя\r\n            user_counts = defaultdict(int)\r\n            for u in updates:\r\n                user_counts[u[\"user_id\"]] += 1\r\n\r\n            # Обновляем жизни для каждого пользователя\r\n            await con.executemany(\r\n                \"\"\"UPDATE users \r\n                   SET lives = MAX(lives - ?, 0)\r\n                   WHERE user_id = ?\"\"\",\r\n                [(count, user_id) for user_id, count in user_counts.items()]\r\n            )\r\n\r\n            # Готовим записи для истории списаний.\r\n            # Предполагаем, что в updates для каждого пользователя поле \"lives\" содержит текущее значение до списания.\r\n            history_records = []\r\n            for u in updates:\r\n                # Если один пользователь появляется несколько раз, мы будем добавлять несколько записей.\r\n                new_lives = u[\"lives\"] - user_counts[u[\"user_id\"]]\r\n                history_records.append((u[\"user_id\"], u[\"task_id\"], new_lives, '-1'))\r\n\r\n            # Выполняем пакетную вставку в history_of_lives\r\n            await con.executemany(\r\n                \"INSERT INTO history_of_lives VALUES (?, ?, ?, ?)\",\r\n                history_records\r\n            )\r\n\r\n            await con.commit()\r\n\r\n        except Exception as e:\r\n            await con.rollback()\r\n            raise e\r\n\r\n\r\nasync def get_today_deadline_for_remind(timezone_id: int) -> list:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        timezone_name = (await get_timezones())[timezone_id]\r\n        tz = pytz.timezone(timezone_name)\r\n        now = datetime.now(tz)\r\n        current_date = (now + timedelta(days=1)).strftime(\"%Y-%m-%d\")\r\n        query = '''SELECT u.user_id, u.course_id, t.task_id, t.task_title, b.block_id\r\n                    FROM tasks t\r\n                    JOIN blocks b ON t.block_id = b.block_id\r\n                    JOIN users u ON b.course_id = u.course_id\r\n                    WHERE u.timezone_id = ? AND t.deadline = ?'''\r\n        con.row_factory = aiosqlite.Row\r\n        async with con.execute(query, (timezone_id, current_date)) as cursor:\r\n            rows = await cursor.fetchall()\r\n            return [dict(row) for row in rows] if rows else []\r\n\r\n\r\nasync def get_today_deadline_for_keyboard(user_id: int):\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        # Получаем часовой пояс пользователя\r\n        timezone_name_cursor = await con.execute(\r\n            '''SELECT timezone \r\n               FROM unique_timezones t\r\n               JOIN users u ON t.timezone_id = u.timezone_id\r\n               WHERE u.user_id = ?''', (user_id,)\r\n        )\r\n        timezone_tuple = await timezone_name_cursor.fetchone()\r\n        if not timezone_tuple:\r\n            raise ValueError(\"Часовой пояс не найден для пользователя\")\r\n        tz_name = timezone_tuple[0]\r\n        tz = pytz.timezone(tz_name)\r\n        now = datetime.now(tz)\r\n\r\n        tomorrow_str = (now + timedelta(days=1)).strftime(\"%Y-%m-%d\")\r\n\r\n        query = '''SELECT u.user_id, u.course_id, t.task_id, t.task_title, b.block_id\r\n                   FROM tasks t\r\n                   JOIN blocks b ON t.block_id = b.block_id\r\n                   JOIN users u ON b.course_id = u.course_id\r\n                   WHERE t.deadline = ?'''\r\n        con.row_factory = aiosqlite.Row\r\n        async with con.execute(query, (tomorrow_str,)) as cursor:\r\n            rows = await cursor.fetchall()\r\n            return [dict(row) for row in rows] if rows else []\r\n\r\n\r\nasync def get_today_new_block() -> list:\r\n    current_date = datetime.now().strftime(\"%Y-%m-%d\")\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        cursor = await con.execute('SELECT course_id FROM blocks WHERE block_start=?', current_date)\r\n        rows = await cursor.fetchall()\r\n        return [row[0] for row in rows] if rows else []\r\n\r\n\r\nasync def update_lives(course_id):\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        await con.execute('UPDATE users SET lives = ? WHERE course_id = ? AND lives != ?', (3, course_id, 0))\r\n        await con.execute('''\r\n                   DELETE FROM history_of_lives\r\n                   WHERE user_id IN (\r\n                       SELECT user_id FROM users WHERE course_id = ?\r\n                   )''', (course_id,))\r\n        await con.execute('INSERT INTO history_of_lives VALUES(?, ?, ?, ?)', ('all_users', None, 3, '+3'))\r\n        await con.commit()\r\n\r\n\r\nasync def get_history_lives_user(user_id: int) -> list:\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = '''SELECT h.lives_after_action, h.action, t.task_title\r\n                   FROM history_of_lives h\r\n                   LEFT JOIN tasks t ON t.task_id = h.task_id\r\n                   WHERE h.user_id = ? OR h.user_id = ?'''\r\n        async with con.execute(query, (user_id, 'all_users')) as cursor:\r\n            result = await cursor.fetchall()\r\n            return [dict(x) for x in result] if result else []\r\n\r\n\r\nasync def get_last_task(user_id):\r\n    async with aiosqlite.connect('educated_platform.db') as con:\r\n        con.row_factory = aiosqlite.Row\r\n        query = '''SELECT u.course_id, t.task_id\r\n                   FROM users u\r\n                   JOIN blocks b ON u.course_id = b.course_id\r\n                   JOIN tasks t ON b.block_id = t.block_id\r\n                   WHERE u.user_id = ?\r\n                   ORDER BY t.deadline DESC \r\n                   LIMIT 1;'''\r\n        async with con.execute(query, (user_id,)) as cursor:\r\n            last_task = await cursor.fetchone()\r\n            return dict(last_task)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/database.py b/database.py
--- a/database.py	(revision 96802b670d37253d439b2386d5f719e7303aea1c)
+++ b/database.py	(date 1744963627267)
@@ -24,9 +24,13 @@
         await con.execute("DROP TABLE IF EXISTS unique_timezones")
         await con.execute("DROP TABLE IF EXISTS history_of_lives")
 
+        await con.execute("PRAGMA foreign_keys = ON;")
+
         await con.execute('''CREATE TABLE IF NOT EXISTS unregistered (
             telegram_username TEXT,
-            course_id INTEGER)''')
+            course_id INTEGER,
+            FOREIGN KEY(course_id) REFERENCES courses(course_id) ON DELETE CASCADE
+        )''')
 
         await con.execute('''CREATE TABLE IF NOT EXISTS users (
             real_name TEXT,
@@ -36,16 +40,21 @@
             timezone_id INTEGER,
             date_of_joining TEXT,
             lives INTEGER,
-            role TEXT)''')
+            role TEXT,
+            FOREIGN KEY(course_id) REFERENCES courses(course_id)
+        )''')
 
-        await con.execute('''CREATE TABLE IF NOT EXISTS courses(
+        await con.execute('''CREATE TABLE IF NOT EXISTS courses (
             course_title TEXT,
-            course_id INTEGER PRIMARY KEY AUTOINCREMENT)''')
+            course_id INTEGER PRIMARY KEY AUTOINCREMENT
+        )''')
 
         await con.execute('''CREATE TABLE IF NOT EXISTS blocks (
             course_id INTEGER,
             block_number INTEGER, 
-            block_id INTEGER PRIMARY KEY AUTOINCREMENT)''')
+            block_id INTEGER PRIMARY KEY AUTOINCREMENT,
+            FOREIGN KEY(course_id) REFERENCES courses(course_id) ON DELETE CASCADE
+        )''')
 
         await con.execute('''CREATE TABLE IF NOT EXISTS tasks (
             task_title TEXT,
@@ -55,20 +64,26 @@
             video_id TEXT,
             abstract_id TEXT,
             link_files TEXT,
-            deadline TEXT)''')
+            deadline TEXT,
+            FOREIGN KEY(block_id) REFERENCES courses(block_id) ON DELETE CASCADE
+        )''')
 
         await con.execute('''CREATE TABLE IF NOT EXISTS exercises (
-             task_id INTEGER,
-             exercise_id INTEGER PRIMARY KEY AUTOINCREMENT,
-             exercise_condition TEXT,
-             exercise_answer TEXT)''')
+            task_id INTEGER,
+            exercise_id INTEGER PRIMARY KEY AUTOINCREMENT,
+            exercise_condition TEXT,
+            exercise_answer TEXT,
+            FOREIGN KEY(task_id) REFERENCES tasks(task_id) ON DELETE CASCADE
+        )''')
 
         await con.execute('''CREATE TABLE IF NOT EXISTS learning_progress (
-             user_id INTEGER, 
-             exercise_id INTEGER, 
-             input_answer TEXT, 
-             right_answer BOOL, 
-             session_id INTEGER)''')
+            user_id INTEGER, 
+            exercise_id INTEGER, 
+            input_answer TEXT, 
+            right_answer BOOL, 
+            session_id INTEGER,
+            FOREIGN KEY(user_id) REFERENCES users(user_id) ON DELETE CASCADE
+        )''')
 
         await con.execute('''CREATE TABLE IF NOT EXISTS sessions (
             session_id INTEGER PRIMARY KEY AUTOINCREMENT,
@@ -76,23 +91,32 @@
             task_id INTEGER,
             is_completed BOOL,
             session_start TEXT,
-            session_end TEXT)''')
+            session_end TEXT,
+            FOREIGN KEY(user_id) REFERENCES users(user_id) ON DELETE CASCADE,
+            FOREIGN KEY(task_id) REFERENCES tasks(task_id) ON DELETE CASCADE
+        )''')
 
         await con.execute('''CREATE TABLE IF NOT EXISTS changed_deadlines (
-                user_id INTEGER,
-                task_id INTEGER,
-                deadline TEXT,
-                PRIMARY KEY (user_id, task_id))''')
+            user_id INTEGER,
+            task_id INTEGER,
+            deadline TEXT,
+            PRIMARY KEY (user_id, task_id),
+            FOREIGN KEY(user_id) REFERENCES users(user_id) ON DELETE CASCADE,
+            FOREIGN KEY(task_id) REFERENCES tasks(task_id) ON DELETE CASCADE
+        )''')
 
         await con.execute('''CREATE TABLE IF NOT EXISTS unique_timezones (
             timezone TEXT,
-            timezone_id INTEGER PRIMARY KEY AUTOINCREMENT)''')
+            timezone_id INTEGER PRIMARY KEY AUTOINCREMENT
+        )''')
 
         await con.execute('''CREATE TABLE IF NOT EXISTS history_of_lives (
             user_id INTEGER,
             task_id INTEGER,
             lives_after_action INTEGER,
-            action TEXT)''')  # action: +1, +3, -1...
+            action TEXT,
+            FOREIGN KEY(user_id) REFERENCES users(user_id) ON DELETE CASCADE
+        )''')
 
         # await con.execute('''CREATE TABLE IF NOT EXISTS  requires_verification (
         #     user_id INTEGER,
@@ -151,7 +175,8 @@
         course_data = (await cursor.fetchall())[0]
         if course_data:
             await con.execute('INSERT INTO users VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
-                              (real_name, telegram_username, user_id, course_data[0], timezone_id, date_of_joining, lives, role))
+                              (real_name, telegram_username, user_id, course_data[0], timezone_id, date_of_joining,
+                               lives, role))
             await con.execute('INSERT INTO history_of_lives VALUES(?, ?, ?, ?)', (user_id, None, None, '+3'))
             await con.execute('DELETE FROM unregistered WHERE telegram_username = ?', (telegram_username,))
             await con.commit()
@@ -568,7 +593,7 @@
         return [row[0] for row in rows] if rows else []
 
 
-async def update_lives(course_id):
+async def update_lives_with_new_block(course_id):
     async with aiosqlite.connect('educated_platform.db') as con:
         await con.execute('UPDATE users SET lives = ? WHERE course_id = ? AND lives != ?', (3, course_id, 0))
         await con.execute('''
@@ -605,3 +630,32 @@
         async with con.execute(query, (user_id,)) as cursor:
             last_task = await cursor.fetchone()
             return dict(last_task)
+
+
+async def update_lives_for_user(user_id: int, new_count_lives: int) -> None:
+    async with aiosqlite.connect('educated_platform.db') as con:
+        cursor = await con.execute('SELECT lives FROM users WHERE user_id = ?', (user_id,))
+        old_count_lives = (await cursor.fetchone())[0]
+        await con.execute('UPDATE users SET lives = ? WHERE user_id = ?', (new_count_lives, user_id))
+        if old_count_lives > new_count_lives:
+            change_operation = '-'
+            difference_lives = old_count_lives - new_count_lives
+        else:
+            change_operation = '+'
+            difference_lives = new_count_lives - old_count_lives
+        action = change_operation + str(difference_lives)
+        await con.execute('INSERT INTO history_of_lives VALUES(?, ?, ?, ?)', (user_id, None, new_count_lives, action))
+        await con.commit()
+
+
+async def get_course_title(course_id: int) -> str:
+    async with aiosqlite.connect('educated_platform.db') as con:
+        cursor = await con.execute('SELECT course_title FROM courses WHERE course_id = ?', (course_id,))
+        course_title = (await cursor.fetchone())[0]
+        return course_title
+
+
+async def delete_all_user_data(user_id: int) -> None:
+    async with aiosqlite.connect('educated_platform.db') as con:
+        await con.execute('DELETE FROM users WHERE user_id = ?', (user_id,))
+        await con.commit()
\ No newline at end of file
Index: callbacks/create_task.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from aiogram.fsm.context import FSMContext\r\nfrom aiogram.fsm.storage.base import StorageKey\r\nfrom aiogram.types import CallbackQuery, Message\r\nfrom aiogram import Router, F\r\nfrom datetime import datetime\r\nfrom bot_instance import bot, dp\r\nfrom google_table import google_client\r\n\r\n\r\nimport calendar\r\nimport state as st\r\nimport database as db\r\nimport keyboard as kb\r\n\r\nrouter = Router()\r\n\r\n\r\n@router.callback_query(F.data == 'add_users')\r\nasync def process_add_users(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    await callback_query.message.answer('Выбери курс', reply_markup=await kb.choose_course_reply())\r\n    await state.set_state(st.AddUsers.choose_course)\r\n\r\n\r\n@router.callback_query(F.data == 'add_lesson')\r\nasync def process_add_lesson(callback_query: CallbackQuery):\r\n    await callback_query.answer()\r\n    await callback_query.message.edit_text(f'Для добавления домашнего задания выбери курс',\r\n                                           reply_markup=await kb.choose_course_inline())\r\n\r\n\r\n@router.callback_query(lambda c: c.data.startswith('choose_course'))\r\nasync def process_increase_block(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    await state.set_state(st.AddTask.choose_course)\r\n    course_name = callback_query.data.split(\":\")[-1]\r\n    course_id = await db.get_course_id(course_name)\r\n    current_block = await db.get_blocks(course_id, current=True)\r\n    await state.update_data(course_id=course_id, current_block=current_block)\r\n    await callback_query.message.edit_text(\r\n        f'Выбери блок\\n\\nТекущий выбор: {current_block} блок',\r\n        reply_markup=await kb.to_change_block(current_block))\r\n\r\n\r\n@router.callback_query(\r\n    lambda c: c.data.startswith(\"increase_block\") or c.data.startswith(\"reduce_block\") or c.data.startswith(\r\n        \"confirm_block\"))\r\nasync def process_increase_block(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n\r\n    action, current_value = callback_query.data.split(\":\")\r\n    selected_block = int(current_value)\r\n    if action == \"increase_block\":\r\n        selected_block += 1\r\n    elif action == \"reduce_block\" and selected_block != 1:\r\n        selected_block -= 1\r\n    elif action == 'confirm_block':\r\n        state_data = await state.get_data()\r\n        course_id = state_data['course_id']\r\n        block_id = await db.check_block_exists(course_id, selected_block)\r\n        await state.update_data(selected_block=selected_block)\r\n        if block_id:\r\n            year = datetime.now().year\r\n            month = datetime.now().month\r\n            await state.set_state(st.AddTask.choose_options)\r\n            await callback_query.message.edit_text('Выбери дату дедлайна',\r\n                                                   reply_markup=await kb.generate_calendar(year, month))\r\n            await state.update_data(block_id=block_id)\r\n        else:\r\n            await callback_query.message.edit_text(\r\n                f'Твой выбор: {selected_block}\\nТекущий блок на курсе: {state_data['current_block']}\\n\\nНачать новый блок и обновить всем пользователям жизни?',\r\n                reply_markup=kb.confirm_new_block_keyboard)\r\n    new_text = f'Выбери блок\\n\\nТекущий выбор: {selected_block} блок'\r\n    if callback_query.message.text != new_text:\r\n        await callback_query.message.edit_text(text=f'Выбери блок\\n\\nТекущий выбор: {selected_block} блок',\r\n                                               reply_markup=await kb.to_change_block(selected_block))\r\n\r\n\r\n@router.callback_query(lambda c: c.data == 'cancel_update_block' or c.data == 'confirm_new_block')\r\nasync def confirm_new_block(callback_query: CallbackQuery, state: FSMContext):\r\n    action = callback_query.data\r\n    state_data = await state.get_data()\r\n    if action == 'cancel_update_block':\r\n        await callback_query.message.edit_text(\r\n            f'Выбери блок\\n\\nТекущий выбор: {state_data['current_block']} блок',\r\n            reply_markup=await kb.to_change_block(state_data['current_block']))\r\n    elif action == 'confirm_new_block':\r\n        year = datetime.now().year\r\n        month = datetime.now().month\r\n        block_id = await db.create_block(state_data['course_id'], state_data['selected_block'])\r\n        await db.update_lives(state_data['course_id'])\r\n        await state.update_data(block_id=block_id)\r\n        await state.set_state(st.AddTask.choose_options)\r\n        await callback_query.message.edit_text('Выбери дату дедлайна',\r\n                                               reply_markup=await kb.generate_calendar(year, month))\r\n\r\n\r\n@router.callback_query(lambda c: c.data.startswith('prev_month') or c.data.startswith('next_month'))\r\nasync def month(callback_query: CallbackQuery):\r\n    action, year, month = callback_query.data.split(\":\")\r\n    year, month = int(year), int(month)\r\n    if action == \"prev_month\":\r\n        if month == 1:\r\n            year -= 1\r\n            month = 12\r\n        else:\r\n            month -= 1\r\n    elif action == \"next_month\":\r\n        if month == 12:\r\n            year += 1\r\n            month = 1\r\n        else:\r\n            month += 1\r\n    new_markup = await kb.generate_calendar(year, month)\r\n    await callback_query.message.edit_reply_markup(reply_markup=new_markup)\r\n\r\n\r\n@router.callback_query(lambda c: c.data.startswith(\"select_day\"))\r\nasync def select_day(callback_query: CallbackQuery):\r\n    _, year, month, day = callback_query.data.split(\":\")\r\n    await callback_query.message.edit_text(\r\n        f\"Дата дедлайна: {day} {calendar.month_name[int(month)]} {year}\\nТребуется файл решений от ученика:\",\r\n        reply_markup=await kb.choose_parameters_task(f'{year}-{month}-{day}'))\r\n\r\n\r\n@router.callback_query((lambda c: c.data.startswith('verif')))\r\nasync def choose_verification(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    _, file_work, deadline_date = callback_query.data.split(':')\r\n    file_work = bool(file_work)\r\n    day, month, year = deadline_date.split('-')\r\n    await state.update_data(file_work=file_work, deadline=deadline_date)\r\n    await callback_query.message.edit_text(\r\n        f'''Дата дедлайна: {day} {calendar.month_name[int(month)]} {year}\\nТребовать файл решений: {'Да' if file_work else 'Нет'}\\nФайлы в заданиях:''',\r\n        reply_markup=kb.availability_files_task)\r\n\r\n\r\n@router.callback_query(lambda c: c.data.startswith('availability_files'))\r\nasync def process_availability_files(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    availability_files = callback_query.data.split(':')[-1]\r\n    await state.update_data(availability_files=True if availability_files == 'Да' else False)\r\n    current_text = callback_query.message.text\r\n    new_text = current_text + f' {availability_files}'\r\n    await callback_query.message.edit_text(text=new_text, reply_markup=kb.confirm_task)\r\n\r\n\r\n@router.callback_query(lambda c: c.data.startswith('finish_task'))\r\nasync def process_finish_task(callback_query: CallbackQuery, state: FSMContext):\r\n    await callback_query.answer()\r\n    action = callback_query.data.split(':')[-1]\r\n    if action == 'edit_task':\r\n        year = datetime.now().year\r\n        month = datetime.now().month\r\n        await callback_query.message.edit_text(f'Выбери дату дедлайна',\r\n                                               reply_markup=await kb.generate_calendar(year, month))\r\n    elif action == 'confirm_task':\r\n        await callback_query.message.edit_reply_markup(reply_markup=None)\r\n        await callback_query.message.answer('Отправь мне название урока')\r\n        await state.set_state(st.AddTask.get_task_title)\r\n\r\n\r\n@router.message(st.AddUsers.choose_course)\r\nasync def process_choose_course(message: Message, state: FSMContext):\r\n    if message.text == 'Создать новый':\r\n        await message.answer('Отправь мне название курса')\r\n        await state.set_state(st.AddUsers.get_course_tittle)\r\n    else:\r\n        await state.update_data(course_tittle=message.text)\r\n        await message.answer('Отправь мне список пользователей')\r\n        await state.set_state(st.AddUsers.get_list_users)\r\n\r\n\r\n@router.message(st.AddUsers.get_course_tittle)\r\nasync def process_get_course_tittle(message: Message, state: FSMContext):\r\n    await state.update_data(course_tittle=message.text)\r\n    await db.create_course(message.text)\r\n    await message.answer('Отправь мне список пользователей')\r\n    await state.set_state(st.AddUsers.get_list_users)\r\n\r\n\r\n@router.message(st.AddUsers.get_list_users)\r\nasync def process_get_list_users(message: Message, state: FSMContext):\r\n    list_users = message.text.split('\\n')\r\n    data = await state.get_data()\r\n    course_id = await db.get_course_id(data['course_tittle'])\r\n    await db.add_users(list_users, course_id)\r\n    _, keyboard = await kb.send_command_menu(message.from_user.id)\r\n    await message.answer('Пользователи были успешно добавлены', reply_markup=keyboard)\r\n\r\n\r\n@router.message(st.AddTask.get_task_title)\r\nasync def process_get_task_title(message: Message, state: FSMContext):\r\n    await state.update_data(task_title=message.text)\r\n    await message.answer('Название было успешно записано. Теперь отправь мне видеозапись урока')\r\n    await state.set_state(st.AddTask.get_video)\r\n\r\n\r\n@router.message(st.AddTask.get_video)\r\nasync def process_get_video(message: Message, state: FSMContext):\r\n    await state.update_data(video_id=message.video.file_id)\r\n    availability_files = await state.get_value('availability_files')\r\n    if availability_files:\r\n        await message.answer('Видео было успешно записано. Теперь отправь ссылку на репозиторий с файлами')\r\n        await state.set_state(st.AddTask.get_files)\r\n    else:\r\n        await message.answer('Видео было успешно записано. Теперь отправь конспект урока')\r\n        await state.set_state(st.AddTask.get_abstract)\r\n\r\n\r\n@router.message(st.AddTask.get_files)\r\nasync def process_get_files(message: Message, state: FSMContext):\r\n    await state.update_data(link_files=message.text)\r\n    await message.answer('Ссылка была успешно записана. Теперь отправь конспект урока')\r\n    await state.set_state(st.AddTask.get_abstract)\r\n\r\n\r\n@router.message(st.AddTask.get_abstract)\r\nasync def process_get_abstract(message: Message, state: FSMContext):\r\n    await state.update_data(abstract_id=message.document.file_id)\r\n    await message.answer('Добавь условия и ответы в гугл таблицу', reply_markup=kb.send_exercise)\r\n    await state.set_state(st.AddTask.verification)\r\n\r\n\r\n@router.callback_query(F.data == 'send_exercise')\r\nasync def process_send_exercise(callback_query: CallbackQuery, state: FSMContext):\r\n    \"\"\"Создаем task. Проверяем, есть ли в задании автопроверка.\"\"\"\r\n    await callback_query.answer()\r\n    state_data = await state.get_data()\r\n    link_files = state_data.get('link_files', None)\r\n    task_id = await db.add_task(state_data['task_title'], state_data['block_id'], state_data['file_work'],\r\n                                state_data['video_id'], state_data['abstract_id'], link_files,\r\n                                state_data['deadline'])\r\n    exercises = await google_client.get_exersice()\r\n    for exercise in exercises:\r\n        exercise_condition = exercise[0]\r\n        exercise_answer = exercise[1]\r\n        await db.add_exercise(task_id, exercise_condition, exercise_answer)\r\n\r\n    users_by_course = await db.get_users_by_course(state_data['course_id'])\r\n    for user_id in users_by_course:\r\n        notification_about_new_task = await bot.send_message(chat_id=user_id,\r\n                               text=f'Привет! Только что был добавлен новый урок: {state_data['task_title']}\\nЧтобы перейти к нему жми на кнопку!',\r\n                               reply_markup=await kb.start_the_task_from_the_reminder(state_data['course_id'],\r\n                                                                                      task_id))\r\n        storage_key = StorageKey(bot_id=bot.id, chat_id=user_id, user_id=user_id)\r\n        state = FSMContext(storage=dp.storage, key=storage_key)\r\n        await state.update_data(rnotification_about_new_task_message_id=notification_about_new_task.message_id)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/callbacks/create_task.py b/callbacks/create_task.py
--- a/callbacks/create_task.py	(revision 96802b670d37253d439b2386d5f719e7303aea1c)
+++ b/callbacks/create_task.py	(date 1744963627267)
@@ -88,7 +88,7 @@
         year = datetime.now().year
         month = datetime.now().month
         block_id = await db.create_block(state_data['course_id'], state_data['selected_block'])
-        await db.update_lives(state_data['course_id'])
+        await db.update_lives_with_new_block(state_data['course_id'])
         await state.update_data(block_id=block_id)
         await state.set_state(st.AddTask.choose_options)
         await callback_query.message.edit_text('Выбери дату дедлайна',
Index: command_menu_admin.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/command_menu_admin.py b/command_menu_admin.py
--- a/command_menu_admin.py	(revision 96802b670d37253d439b2386d5f719e7303aea1c)
+++ b/command_menu_admin.py	(date 1744963627267)
@@ -1,2 +1,30 @@
+from aiogram.fsm.context import FSMContext
+from aiogram.fsm.storage.base import StorageKey
+from aiogram.types import CallbackQuery, Message
+from aiogram import Router, F
+from datetime import datetime
+from bot_instance import bot, dp
+from google_table import google_client
+
+import calendar
+import state as st
+import database as db
+import keyboard as kb
 
+router = Router()
 
+
+@router.callback_query(lambda c: c.data.startswith('cancel_deleting') or c.data.startswith('confirm_deleting'))
+async def process_deleting_user(callback_query: CallbackQuery):
+    action, user_id = callback_query.data.split(':')
+    user_id = int(user_id)
+    if action == 'cancel_deleting':
+        user_data = await db.get_data_user(user_id)
+        course_title = await db.get_course_title(user_data['course_id'])
+        timezone = (await db.get_timezones())[user_data['timezone_id']]
+        user_data_for_table = [user_data['real_name'], user_data['telegram_username'], course_title, user_id, timezone, user_data['date_of_joining'], 'student', 3]
+        await google_client.add_user_in_table(user_data_for_table)
+        await callback_query.answer('Удаление было отменено. Все данные пользоателя восстановлены')
+    else:
+        await db.delete_all_user_data(user_id)
+        await callback_query.answer('Пользователь успешно удален')
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"72d8baad-2a73-484a-8cc9-4ec8f1a86f25\" name=\"Changes\" comment=\"добавлена адаптация кнопки в главное меню под новую функцию\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/EducatedPlatform.iml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/EducatedPlatform.iml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/misc.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/misc.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/educated_platform.db\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/educated_platform.db\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/registration.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/registration.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;IlyaTimchuck&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/IlyaTimchuck/EducatedPlatform.git&quot;,\r\n    &quot;accountId&quot;: &quot;0e8c499a-e6aa-4e6f-90fb-34acffe04e66&quot;\r\n  }\r\n}</component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 1\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2s0xh0I6YShiUAj4jNGvrY50LiA\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Python.Unnamed.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.callbacks.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.database.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.google_table.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.main.executor&quot;: &quot;Run&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;master&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/EducatedPlatform&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.lookFeel&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\" selected=\"Python.main\">\r\n    <configuration name=\"Unnamed\" type=\"PythonConfigurationType\" factoryName=\"Python\" nameIsGenerated=\"true\">\r\n      <module name=\"EducatedPlatform\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"PythonConfigurationType\" factoryName=\"Python\">\r\n      <module name=\"EducatedProject\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"database\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"EducatedPlatform\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/database.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"google_table\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"EducatedPlatform\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/google_table.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"main\" type=\"PythonConfigurationType\" factoryName=\"Python\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <module name=\"EducatedPlatform\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <envs>\r\n        <env name=\"PYTHONUNBUFFERED\" value=\"1\" />\r\n      </envs>\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"$PROJECT_DIR$\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"true\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"$PROJECT_DIR$/main.py\" />\r\n      <option name=\"PARAMETERS\" value=\"\" />\r\n      <option name=\"SHOW_COMMAND_LINE\" value=\"false\" />\r\n      <option name=\"EMULATE_TERMINAL\" value=\"false\" />\r\n      <option name=\"MODULE_MODE\" value=\"false\" />\r\n      <option name=\"REDIRECT_INPUT\" value=\"false\" />\r\n      <option name=\"INPUT_FILE\" value=\"\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"Tox\" factoryName=\"Tox\">\r\n      <module name=\"EducatedProject\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"docs\" factoryName=\"Docutils task\">\r\n      <module name=\"EducatedProject\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"docutils_input_file\" value=\"\" />\r\n      <option name=\"docutils_output_file\" value=\"\" />\r\n      <option name=\"docutils_params\" value=\"\" />\r\n      <option name=\"docutils_task\" value=\"\" />\r\n      <option name=\"docutils_open_in_browser\" value=\"false\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"docs\" factoryName=\"Sphinx task\">\r\n      <module name=\"EducatedProject\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"docutils_input_file\" value=\"\" />\r\n      <option name=\"docutils_output_file\" value=\"\" />\r\n      <option name=\"docutils_params\" value=\"\" />\r\n      <option name=\"docutils_task\" value=\"\" />\r\n      <option name=\"docutils_open_in_browser\" value=\"false\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"tests\" factoryName=\"Autodetect\">\r\n      <module name=\"EducatedProject\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"_new_additionalArguments\" value=\"&quot;&quot;\" />\r\n      <option name=\"_new_target\" value=\"&quot;&quot;\" />\r\n      <option name=\"_new_targetType\" value=\"&quot;PATH&quot;\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"tests\" factoryName=\"Doctests\">\r\n      <module name=\"EducatedProject\" />\r\n      <option name=\"ENV_FILES\" value=\"\" />\r\n      <option name=\"INTERPRETER_OPTIONS\" value=\"\" />\r\n      <option name=\"PARENT_ENVS\" value=\"true\" />\r\n      <option name=\"SDK_HOME\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"IS_MODULE_SDK\" value=\"false\" />\r\n      <option name=\"ADD_CONTENT_ROOTS\" value=\"true\" />\r\n      <option name=\"ADD_SOURCE_ROOTS\" value=\"true\" />\r\n      <option name=\"SCRIPT_NAME\" value=\"\" />\r\n      <option name=\"CLASS_NAME\" value=\"\" />\r\n      <option name=\"METHOD_NAME\" value=\"\" />\r\n      <option name=\"FOLDER_NAME\" value=\"\" />\r\n      <option name=\"TEST_TYPE\" value=\"TEST_SCRIPT\" />\r\n      <option name=\"PATTERN\" value=\"\" />\r\n      <option name=\"USE_PATTERN\" value=\"false\" />\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Python.Unnamed\" />\r\n      <item itemvalue=\"Python.database\" />\r\n      <item itemvalue=\"Python.google_table\" />\r\n      <item itemvalue=\"Python.main\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Python.main\" />\r\n        <item itemvalue=\"Python.google_table\" />\r\n        <item itemvalue=\"Python.database\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-python-sdk-fc1d50d2d915-aa17d162503b-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-243.24978.54\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"72d8baad-2a73-484a-8cc9-4ec8f1a86f25\" name=\"Changes\" comment=\"\" />\r\n      <created>1737606408278</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1737606408278</updated>\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 96802b670d37253d439b2386d5f719e7303aea1c)
+++ b/.idea/workspace.xml	(date 1744963753452)
@@ -8,7 +8,13 @@
       <change beforePath="$PROJECT_DIR$/.idea/EducatedPlatform.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/EducatedPlatform.iml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/callbacks/create_task.py" beforeDir="false" afterPath="$PROJECT_DIR$/callbacks/create_task.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/command_menu_admin.py" beforeDir="false" afterPath="$PROJECT_DIR$/command_menu_admin.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/database.py" beforeDir="false" afterPath="$PROJECT_DIR$/database.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/educated_platform.db" beforeDir="false" afterPath="$PROJECT_DIR$/educated_platform.db" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/google_table.py" beforeDir="false" afterPath="$PROJECT_DIR$/google_table.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/keyboard.py" beforeDir="false" afterPath="$PROJECT_DIR$/keyboard.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/main.py" beforeDir="false" afterPath="$PROJECT_DIR$/main.py" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/registration.py" beforeDir="false" afterPath="$PROJECT_DIR$/registration.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -34,8 +40,8 @@
 }</component>
   <component name="GithubPullRequestsUISettings">{
   &quot;selectedUrlAndAccountId&quot;: {
-    &quot;url&quot;: &quot;https://github.com/IlyaTimchuck/EducatedPlatform.git&quot;,
-    &quot;accountId&quot;: &quot;0e8c499a-e6aa-4e6f-90fb-34acffe04e66&quot;
+    &quot;url&quot;: &quot;https://github.com/IlyaTimchuck/EducatedPlatform&quot;,
+    &quot;accountId&quot;: &quot;0673eef9-6c6a-4377-9177-4560af06ab4a&quot;
   }
 }</component>
   <component name="ProjectColorInfo">{
@@ -269,7 +275,7 @@
   <component name="SharedIndexes">
     <attachedChunks>
       <set>
-        <option value="bundled-python-sdk-fc1d50d2d915-aa17d162503b-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-243.24978.54" />
+        <option value="bundled-python-sdk-6a3326d57233-c546a90a8094-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-242.24807.21" />
       </set>
     </attachedChunks>
   </component>
